$BLOCK COMMENT

                    M_StopWatch Version 1.1

  M_StopWatch is a Fortran 90 module for portable, easy-to-use
  measurement of execution time.  It supports four clocks

     o wall clock
     o CPU clock
     o user CPU clock
     o system CPU clock

  and returns all times in seconds.

  It provides a simple means of determining which clocks are available,
  and the precision of those clocks.

  M_StopWatch is used by instrumenting your code with subroutine calls
  that mimic the operation of a stop watch.  M_StopWatch supports multiple
  watches, and provides the concept of watch groups to allow functions
  to operate on multiple watches simultaneously.

  For further information on using M_StopWatch, see the User Guide or
  man pages.

  The M_StopWatch software and documentation have been produced as part
  of work done by the U.S. Government, and are not subject to copyright
  in the United States.

  William F. Mitchell
  mitchell@cam.nist.gov
  National Institute of Standards and Technology
  December 2, 1996

$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK COMMENT

The research software provided on this web site (“software”) is provided by
NIST as a public service. You may use, copy and distribute copies of the
software in any medium, provided that you keep intact this entire notice. You
may improve, modify and create derivative works of the software or any portion
of the software, and you may copy and distribute such modifications or works.
Modified works should carry a notice stating that you changed the software and
should note the date and nature of any such change. Please explicitly
acknowledge the National Institute of Standards and Technology as the source of
the software.

The software is expressly provided “AS IS.” NIST MAKES NO WARRANTY OF ANY KIND,
EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF LAW, INCLUDING, WITHOUT
LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST NEITHER REPRESENTS NOR
WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR-FREE,
OR THAT ANY DEFECTS WILL BE CORRECTED. NIST DOES NOT WARRANT OR MAKE ANY
REPRESENTATIONS REGARDING THE USE OF THE SOFTWARE OR THE RESULTS THEREOF,
INCLUDING BUT NOT LIMITED TO THE CORRECTNESS, ACCURACY, RELIABILITY, OR
USEFULNESS OF THE SOFTWARE.

You are solely responsible for determining the appropriateness of using and
distributing the software and you assume all risks associated with its use,
including but not limited to the risks and costs of program errors, compliance
with applicable laws, damage to or loss of data, programs or equipment, and the
unavailability or interruption of operation. This software is not intended to be
used in any situation where a failure could cause risk of injury or damage to
property. The software was developed by NIST employees. NIST employee
contributions are not subject to copyright protection within the United States.

$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file M_stopwatch.3m_stopwatch.txt
.TH M_STOPWATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH OVERVIEW"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
M_stopwatch(3f)(3f) - [M_stopwatch::INTRO] package for measuring cpu and wall clock
execution time (LICENSE:PD)

.SH SYNOPSIS
M_StopWatch is a Fortran 90 module for measuring
execution time of program segments.  M_StopWatch is
designed to be a portable, easy-to-use means of
measuring execution time.  It supports the wall clock,
CPU clock, and a breakdown of the CPU clock into user and
system times. It returns all times in seconds.  It
provides a simple means of determining which clocks are
available, and the precision of those clocks.

M_StopWatch is used by instrumenting your code with
subroutine calls that mimic the operation of a stop
watch.  The primary routines are
.B start_watch, stop_watch, reset_watch, read_watch,
and
.B print_watch.
M_StopWatch supports multiple watches, and provides the
concept of watch groups to allow functions to operate
on multiple watches simultaneously.

.SH DESCRIPTION
The entities in M_StopWatch that have public
accessibility are two derived types and fifteen
subroutines (one of which is a function subroutine).
Any program unit that references any of these entities
must use the
.I M_stopwatch
module, i.e., must contain the statement

use M_stopwatch

The derived types are:

.IP o
.I watchtype
-- used for declaring a variable to be a watch

.IP o
.I watchgroup
-- used for declaring a variable to be a handle for a
group of watches

.LP

These two types have public accessibility, but the
internals of the type are private.  Any operations
performed on a variable of one of these types must be
performed by one of the M_StopWatch subroutines.

This man page describes, in general terms, the
operations that can be performed by the M_StopWatch
subroutines.  The formal interfaces and detailed
descriptions of the routines can be found in the
individual man pages.

A watch is a variable declared to be of type
.I watchtype.
It can be passed to subroutines as an actual argument
or through modules like any Fortran variable, but can
only be operated on by the M_StopWatch subroutines.
Watches must be created by subroutine
.B create_watch
before they are used.  Attempting to use a watch that
has not been created will generate a Fortran 90 error,
from attempting to pass a pointer with undefined
association status to the Fortran intrinsic function
.B associated.
Watches must be destroyed when no longer useful.  For
example, consider a local variable of type
.I watchtype
in a subroutine.  Since the contents of a local
variable are lost when the subroutine returns, the
watch should be destroyed before returning to the
calling program.  Failure to destroy watches can lead
to a memory leak.

.IP o
.B create_watch
-- creates a watch

.IP o
.B destroy_watch
-- destroys a watch

.LP

Watches can optionally be given a name (up to 132
characters) through an optional argument,
.I name,
in
.B create_watch.
This name is used in error messages and
.B print_watch
to identify the watch in the printed output.

Different applications demand different definitions of
``time''.  M_StopWatch supports four clocks in each
watch, with each clock measuring a different concept of
time.  All of them measure time in seconds.

.IP o
user -- the amount of CPU time used by the user's
program

.IP o
sys -- the amount of CPU time used by the system in
support of the user's program

.IP o
cpu -- the total CPU time, i.e., user+sys

.IP o
wall -- the wall clock time, i.e., elapsed real time

.LP

It is not required that all clocks be used.  A watch
can be created with any combination of the four clocks.
You can also specify a set of
.I default clocks
to be used whenever the clocks are not explicitly
determined.

Since Fortran 90 does not contain an intrinsic function
for CPU time, the implementation of the cpu, sys and
user clocks is system dependent.  Some implementations
may support only cpu and wall, not user and sys.  Some
implementations may support only wall.  Since the
Fortran 90 standard requires the existence of a
.B system_clock
subroutine, but does not require that it provide clock
information, it is possible that some implementations
might not support wall.  Clock availability can be
determined by
.B inquiry_stopwatch.
Unavailable clocks will automatically be removed from
the set of default clocks, but if a clock that is not
available is explicitly requested, a warning message
will be generated.

M_StopWatch supports multiple watches simultaneously.
Often it is useful to perform the same operation on
several watches.  This is essential for correct
operation of
.B pause_watch
and
.B end_pause_watch,
and can also be convenient for procedures like
.B read_watch, print_watch,
and
.B reset_watch.
To facilitate this, M_StopWatch supports the concept of
.I watch groups.
When calling a M_StopWatch subroutine, a watch group can
be specified instead of a watch.  The group is
referenced by a variable of type
.I watchgroup.
Watch groups must be created before they are used.
Attempting to use a watch group that has not been
created will generate a Fortran 90 error, from
attempting to pass a pointer with undefined association
status to the Fortran intrinsic function
.B associated.
Watch groups must be destroyed when no longer useful.
The watches themselves are not destroyed, only the
grouping of them.  Failure to destroy watch groups can
lead to a memory leak.

.IP o
.B create_watchgroup
-- creates a new watch group

.IP o
.B destroy_watchgroup
-- destroys a watch group (but not the watches in the
group)

.LP

Most M_StopWatch subroutines take
.I watch
as the first dummy argument, and accept several forms
of
.I watch.
The forms are:

.IP o
type (watchtype) watch -- a single watch

.IP o
type (watchtype) watch(:)  -- an array of watches

.IP o
type (watchgroup) watch -- a watch group handle

.LP

In most M_StopWatch routines, an array of watches can be
specified by an array constructor in the calling
statement, for example:

type (watchtype) watch ::  w1, w2, w3

call print_watch( (/w1,w2,w3/) )

However, this can not be used in routines where
.I watch
has intent OUT or intent INOUT, because the array
constructor is actually an expression, not a list of
the variables.  Currently this includes the routines
.B create_watch
and
.B destroy_watch.

Most M_StopWatch subroutines take
.I clock
as the (optional) second dummy argument to determine
which of the four clocks will be affected by the
action.
.I clock
can be one of the character strings 'user', 'sys',
\'cpu', or 'wall', or can be an array of such character
strings to specify more than one clock.  Since
.I clock
is always intent IN, an array of clock types can be
built with an array constructor.  However, note that
Fortran 90 requires all character strings in such a
construction to have the same length.  Thus 'sys' and
\'cpu' should be padded with a blank, as in:

call start_watch(watch, (/'user','sys ','cpu '/) )

If the optional argument
.I clock
is omitted, the current set of default clocks is used.
The set of default clocks is set with
.B option_stopwatch
and initially consists of all available clocks.

A M_StopWatch watch is operated on by subroutine calls
that correspond to the actions performed with a common
stop watch.  The basic operation of a watch involves
starting it, stopping it, and resetting it to 0.

.IP o
.B start_watch
-- starts an idle watch, like the Start/Stop button on
a stop watch

.IP o
.B stop_watch
-- stops a running watch, like the Start/Stop button on
a stop watch

.IP o
.B reset_watch
-- sets the clocks on a watch to 0.0, like the Reset
button on a stop watch

.LP

Of course, running a stop watch is of little use unless
you can see what it says.

.IP o
.B read_watch
-- returns the current clock value of a watch, like
looking at the display of a stop watch

.IP o
.B print_watch
-- prints the current clock value of a watch to an
output device.  To push the analogy to the limit,
imagine a stop watch with a printer attached to it.

.LP

The routine
.B read_watch
is a function subroutine.  The result is either a
scalar, array of rank one, or array of rank two
depending on whether
.I watch
and
.I clock
are scalars or arrays.

When measuring CPU time, it is often desirable to not
include the time used by certain parts of the code,
such as printing or graphics.  In a subroutine, you
might not know which of the clocks are currently
running, so you can not simply stop them before the I/O
and start them up again after the I/O. For this,
M_StopWatch provides the pause function.

.IP o
.B pause_watch
-- temporarily suspend the running watches

.IP o
.B end_pause_watch
-- resume suspended watches

.LP

Besides
.B create_watchgroup
and
.B destroy_watchgroup,
there are two operations that can be performed on
.I watchgroup
variables:

.IP o
.B join_watchgroup
-- adds a watch to a watch group

.IP o
.B leave_watchgroup
-- removes a watch from a watch group

.LP

Subroutines are provided to set several options within
M_StopWatch, to determine the current value of these
options, and to determine system dependent values of
the implementation.

.IP o
.B option_stopwatch
-- sets options within M_StopWatch.

.IP o
.B inquiry_stopwatch
-- returns values of options and system dependent
values

.LP

See
.BR "option_stopwatch" "(3)"
and
.BR "inquiry_stopwatch" "(3)"
for a description of the options and system dependent
values that can be set and read.

.SH DIAGNOSTICS
All M_StopWatch subroutines take an optional intent OUT
integer argument
.I err
which, if present, returns a status code.  The code is
the sum of the values listed below.

Errors can also be determined through printed error
messages.  An error message will be printed to a
specified I/O unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

All errors are non-fatal.  If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the requested operation will not
be performed.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1
Watch needs to be created.  This error occurs if you
attempt to use a watch that has been destroyed.  The
watch must first be created again.  See also the
comment about watches that have never been created in
the BUGS section.

.IP 2
Watch is in the wrong state for this operation.  This
occurs when you attempt to start a watch that is
currently running, stop a watch that is not running,
etc.

.IP 4
Watch is in an unknown state.  This occurs if M_StopWatch
does not recognize the state (running, stopped, etc.)
that the watch is in.  This error should not occur, and
indicates an internal bug in M_StopWatch.

.IP 8
Invalid clock type.  This occurs if
.I clock
is present and one of the specified clocks is not
supported by the implementation.  See
.BR "inquiry_stopwatch" "(3)"
to determine what clocks are available.

.IP 16
Too many clocks specified.  This occurs when the
argument
.I clock
is an array longer than four.

.IP 32
Number of names is not equal to number of watches.
This occurs in
.B create_watch
if the array of watch names is not of the same length
as the array of watches.

.IP 64
Character string too long.  This occurs when a watch
name with more than 132 characters is passed into
.B create_watch.

.IP 128
Watch not found in given group.  This occurs when you
attempt to remove a watch from a group that it does not
belong to.

.IP 256
I/O unit is not open for writing.  This can occur from
.B print_watch
or when printing an error message.

.IP 512
Failed to allocate required memory.  When a M_StopWatch
routine is called with an array or group of watches,
temporary memory is allocated.  This error occurs if
the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array or group of watches.
The operation is performed, but be aware that other
problems could develop as a result of the deallocate
error.

.IP 2048
Illegal output form.  This error occurs in
.B option_stopwatch
or
.B print_watch
if the given print format is not one of the valid
strings (see
.BR "print_watch" "(3)"
).

.LP

In addition to the run time diagnostics generated by
M_StopWatch, the following problems may arise:

.IP o
In Fortran 90, the character strings in an array
constructor must all have the same length.  Pad three
letter clock names with a blank on the right to make a
four character string, for example, 'cpu ', and pad
watch names so they all have the same length (within an
array constructor).

.IP o
In
.B create_watch
and
.BI "destroy_watch," " watch"
has intent OUT or INOUT, so you cannot use an array
constructor as an actual argument to construct an array
of watches.  Some compilers will recognize this as a
compile time error, but will generate an obscure error
message, such as ``no specific match for generic
name''.

.SH EXAMPLE
.nf

! program demo_M_stopwatch and modules
! The following times are measured:
!
!  o each phase each time through the loop
!  o total time for each phase
!  o the total time
!
!  There will be printed output that should not be included in the
!  measured time.
!
module globals
use M_stopwatch
implicit none
private
public :: watchgroup
public :: setup_watches

! the group with all the watches; global var
type (watchgroup), public :: ALL_GROUPS

type (watchtype), public, dimension(5) :: w
! The watches are: w(1) time for phase 1 this time through the loop
!                  w(2) time for phase 2 this time through the loop
!                  w(3) total time for phase 1
!                  w(4) total time for phase 2
!                  w(5) total time
! The watch groups are: GROUPS_FOR_ONE phase 1 times w(1) and w(3)
!                       GROUPS_FOR_TWO phase 2 times w(2) and w(4)
!                       ALL_GROUPS all of them (declared in module globals)
type (watchgroup), public :: GROUPS_FOR_ONE, GROUPS_FOR_TWO
contains
subroutine setup_watches

   ! Measure only cpu and wall time
   call option_stopwatch(default_clock=(/"cpu ","wall"/))
   call create_watch(w,name=(/ "phase 1      ", &      ! create the watches
                               "phase 2      ", &
                               "total phase 1", &
                               "total phase 2", &
                               "Total        " /) )
   call create_watchgroup(w(1),GROUPS_FOR_ONE)         ! create the groups
   call join_watchgroup(w(3),GROUPS_FOR_ONE)
   call create_watchgroup(w(2:4:2),GROUPS_FOR_TWO)     ! a shorter way
   call create_watchgroup(w,ALL_GROUPS)
   call start_watch(w(5))                              ! start the total time

end subroutine setup_watches


end module globals

module workers
implicit none
! The routines being measured
public :: subone
contains

subroutine subone(n,c) ! just to give us something to time.
use M_stopwatch
use globals
integer, intent(in) :: n
real, intent(out)   :: c
integer :: i
real :: a=2.0,b
b=real(n)
do i=1,n
   c=a*b
end do

call pause_watch(ALL_GROUPS)
write(unit=*,fmt=*) "Performed ",n," multiplications"
call end_pause_watch(ALL_GROUPS)

end subroutine subone

end module workers

program demo_M_stopwatch
use M_stopwatch
use globals
use workers
implicit none

integer :: i, nmult                ! loop counter, number of multiplies to do
logical :: cpu_is_there            ! flag for cpu clock
real    :: zz

call setup_watches()

nmult = 200000
do i=1,3
   write(*,'(a)')repeat('=',70)
   write(*,*)'LOOP',i,':'
   ! reset the watches that measure the time for this loop
   call reset_watch(w(1:2))
   ! start the phase 1 watches, do phase 1, and stop the phase 1 watches
   call start_watch(GROUPS_FOR_ONE)
   nmult = 5*nmult
   call subone(nmult,zz)
   call stop_watch(GROUPS_FOR_ONE)

   call start_watch(GROUPS_FOR_TWO)       ! same for phase 2
   nmult = 2*nmult
   call subone(nmult,zz)
   call stop_watch(GROUPS_FOR_TWO)

! pause the cpu clock of the total time watch while printing the current times,
! if the cpu clock is available on this implementation, but leave the wall
! clock running.  The call to inquiry_stopwatch should be outside the loop, but
! this should make a clearer illustration.

   call inquiry_stopwatch(cpu_avail=cpu_is_there)
   if (cpu_is_there) then
      call pause_watch(w(5),"cpu")
   end if

   write(*,'(a)')repeat('-',70)
   call print_watch(w(1:2),title="Times for this loop")
   write(*,'(a)')repeat('-',70)
   call print_watch(w(3:4),title="Total times so far")

   if (cpu_is_there) then
      call end_pause_watch(w(5),"cpu")
   end if

end do

write(*,'(a)')repeat('=',70)
! print the total times
call print_watch([w(3),w(4),w(5)],title="Final total times")

write(unit=*,fmt=*)&
&"Note: the difference between the sum of the first two wall clocks"
write(unit=*,fmt=*)&
&"      and the Total wall clock is due to not pausing the wall clock"
write(unit=*,fmt=*)&
&"      on the Total watch while printing."

call destroy_watch(w)                ! destroy the watches
end program demo_M_stopwatch
.fi

Expected output:

.nf
======================================================================
 LOOP           1 :
 Performed      1000000  multiplications
 Performed      2000000  multiplications
----------------------------------------------------------------------
Times for this loop
  phase 1:
        cpu=    0.00 wall=    0.00
  phase 2:
        cpu=    0.01 wall=    0.02
----------------------------------------------------------------------
Total times so far
  total phase 1:
        cpu=    0.00 wall=    0.00
  total phase 2:
        cpu=    0.01 wall=    0.02
======================================================================
 LOOP           2 :
 Performed     10000000  multiplications
 Performed     20000000  multiplications
----------------------------------------------------------------------
Times for this loop
  phase 1:
        cpu=    0.05 wall=    0.05
  phase 2:
        cpu=    0.11 wall=    0.11
----------------------------------------------------------------------
Total times so far
  total phase 1:
        cpu=    0.05 wall=    0.05
  total phase 2:
        cpu=    0.12 wall=    0.12
======================================================================
 LOOP           3 :
 Performed    100000000  multiplications
 Performed    200000000  multiplications
----------------------------------------------------------------------
Times for this loop
  phase 1:
        cpu=    0.49 wall=    0.48
  phase 2:
        cpu=    0.97 wall=    0.99
----------------------------------------------------------------------
Total times so far
  total phase 1:
        cpu=    0.53 wall=    0.53
  total phase 2:
        cpu=    1.09 wall=    1.11
======================================================================
Final total times
  total phase 1:
        cpu=    0.53 wall=    0.53
  total phase 2:
        cpu=    1.09 wall=    1.11
  Total:
        cpu=    1.62 wall=    1.64
 Note: the difference between the sum of the first two wall clocks
       and the Total wall clock is due to not pausing the wall clock
       on the Total watch while printing.
.fi

.SH ALTERNATIVES

If you simply need to time a certain portion of the code and do not wish to use the
module the SYSTEM_CLOCK(3f) intrinsic may be sufficient:

.nf
   :
   :
call system_clock(count_rate=clock_rate) !Find the time rate
call system_clock(count=clock_start)     !Start Timer

call do_something_subroutine             !This is what gets timed

call system_clock(count=clock_stop)      ! Stop Timer
e_time = real(clock_stop-clock_start)/real(clock_rate)
   :
   :
.fi

For full timing analysis during the development cycle
programming environments generally provide a profiler tool.

If you use the GNU compiler, check out gprof.
In short, you'll add the -pg flag to your compiler, like so:
.nf
gfortran -g -pg -0 myprogram myprogram.F
.fi
Then, run the program and a file called "gmon.out" will be
generated. Then, for example,  call
.nf
gprof --line myprogram gmon.out
.fi
This will give a line-by-line CPU time profile.


MPI_WTIME: This is a high resolution wall-clock that will work anywhere
MPI is available. The downside is that if your program doesn't already
use MPI, you'll have to wrap MPI around it (which isn't hard). Here is
a simple example:
.nf
  include 'mpif.h'
  DOUBLE PRECISION :: start, end
  start = MPI_Wtime()

  ! code to be timed

  end   = MPI_Wtime()
  write(*,*) 'That took ',end-start,' seconds'
.fi

.SH BUGS
It cannot be determined whether or not a watch variable
or watch group has been created (passed as an argument
to
.B create_watch
or
.BR "create_watchgroup" ")."
If a watch or watch group that has never been created
is passed into a M_StopWatch subroutine, it might
generate a Fortran error due to passing a pointer with
undefined association status to the Fortran intrinsic
function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
V1.0: William F. Mitchell, william.mitchell@nist.gov -- January 3, 1997
.br
National Institute of Standards and Technology
.br
.br
V1.1: John S. Urban, urbanjost@comcast.net  -- September 22, 2017
.br

.SH SEE ALSO
create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
join_watchgroup(3), leave_watchgroup(3),
option_stopwatch(3), pause_watch(3), print_watch(3),
read_watch(3), reset_watch(3), start_watch(3),
stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$!==================================================================================================================================
$!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
$!==================================================================================================================================
module M_stopwatch
$IFNDEF GITHUB
use M_system, only : system_cpu_time
$ELSE
use,intrinsic     :: iso_c_binding,   only : c_float, c_int, c_char
use,intrinsic     :: iso_c_binding,   only : c_ptr, c_f_pointer, c_null_char, c_null_ptr
!use,intrinsic     :: iso_c_binding
!use,intrinsic     :: iso_fortran_env, only : int8, int16, int32, int64 !x!, real32, real64, real128, dp=>real128
$ENDIF
implicit none
private

$@(#) M_stopwatch::M_stopwatch(3f): package for measuring cpu and wall clock

public :: create_watch, destroy_watch, start_watch, stop_watch, reset_watch, &
       read_watch, print_watch, pause_watch, end_pause_watch, &
       option_stopwatch, inquiry_stopwatch, create_watchgroup, destroy_watchgroup, &
       join_watchgroup, leave_watchgroup

private :: create_watch_aa, create_watch_as, create_watch_sa, create_watch_ss, &
     destroy_watch_aa, destroy_watch_as, destroy_watch_sa, destroy_watch_ss, &
     start_watch_aa, start_watch_as, start_watch_sa, start_watch_ss, start_watch_ga, start_watch_gs, &
     stop_watch_aa, stop_watch_as, stop_watch_sa, stop_watch_ss, stop_watch_ga, stop_watch_gs, &
     reset_watch_aa, reset_watch_as, reset_watch_sa, reset_watch_ss, reset_watch_ga, reset_watch_gs, &
     pause_watch_aa, pause_watch_as, pause_watch_sa, pause_watch_ss, pause_watch_ga, pause_watch_gs, &
     end_pause_watch_aa, end_pause_watch_as, end_pause_watch_sa, end_pause_watch_ss, &
     end_pause_watch_ga, end_pause_watch_gs, &
     read_watch_aa, read_watch_as, read_watch_sa, read_watch_ss, &
     read_watch_ax, read_watch_sx, &
     print_watch_aa, print_watch_as, print_watch_sa, print_watch_ss, print_watch_ga, print_watch_gs, &
     option_stopwatch_a, option_stopwatch_s, &
     create_watchgroup_a, create_watchgroup_s, &
     join_watchgroup_a, join_watchgroup_s, &
     leave_watchgroup_a, leave_watchgroup_s, &
     which_clocks, which_clocks_a, which_clocks_s, &
     create_watch_actual, destroy_watch_actual, start_watch_actual, stop_watch_actual, &
     reset_watch_actual, pause_watch_actual, end_pause_watch_actual, &
     read_watch_actual, print_watch_actual, create_watchgroup_actual, &
     join_watchgroup_actual, leave_watchgroup_actual, &
     err_handler_watch, print_time, free_watch_list
!----------------------------------------------------
! The following parameters are defined:

! M_StopWatch version number
character(len=16), private, parameter :: sw_version = "1.1"

! status of clocks
integer, private, parameter :: STOPPED = 1, &
                      RUNNING = 2, &
                      PAUSED  = 3, &
                      OMITTED = 4
! error codes
integer, private, parameter :: ERR_CREATE    = 1, &
                      ERR_BAD_STATE = 2, &
                      ERR_UNK_STATE = 4, &
                      ERR_CLOCK     = 8, &
                      ERR_TMC       = 16, &
                      ERR_NAMES     = 32, &
                      ERR_C2LONG    = 64, &
                      ERR_GROUP     = 128, &
                      ERR_IO        = 256, &
                      ERR_ALLOC     = 512, &
                      ERR_DEALLOC   = 1024, &
                      ERR_FORM      = 2048

! length of character strings
integer, private, parameter :: CLOCK_LEN = 4, NAME_LEN = 132, FORM_LEN = 12
!----------------------------------------------------

!----------------------------------------------------
! The following types are defined:

type, private :: clocks
   real :: cpu, user, sys
   integer :: wall
end type clocks

type, private :: status_type
   integer :: cpu, user, sys, wall
end type status_type

type, private :: watch_actual
   character(len=NAME_LEN) :: name
   type (status_type) :: status
   type (clocks) :: last_read
   type (clocks) :: elapsed
end type watch_actual

type, public :: watchtype
   private
   type (watch_actual), pointer :: ptr
end type watchtype

type, private :: watch_pointer
   type (watch_actual), pointer :: ptr
end type watch_pointer

type, private :: watch_list
   type (watch_actual), pointer :: this_watch
   type (watch_list), pointer :: next
end type watch_list

type, public :: watchgroup
   private
   type (watch_list), pointer:: head
   integer :: wgsize
end type watchgroup

!----------------------------------------------------
!----------------------------------------------------
! The following variables are defined:

logical, private :: do_cpu, do_user, do_sys, do_wall
character(len=CLOCK_LEN), private, allocatable, dimension(:) :: default_clocks
integer, private, save :: iounit = 6, errunit = 6
logical, private, save :: errprint = .true., errabort = .false.
character(len=FORM_LEN), private, save :: default_form = "sec"

!----------------------------------------------------
!----------------------------------------------------
! Non-module procedures used are:

! this will be reinserted when F allows interface blocks
!interface

!   subroutine system_cpu_time(cpu,user,sys)
!   implicit none
!   real, intent(out) :: cpu, user, sys
!   end subroutine system_cpu_time

!end interface
!----------------------------------------------------
!----------------------------------------------------
! Generic procedure names are:

interface create_watch
   module procedure create_watch_aa, create_watch_as, create_watch_sa, create_watch_ss
end interface

interface destroy_watch
   module procedure destroy_watch_aa, destroy_watch_as, destroy_watch_sa, destroy_watch_ss
end interface

interface start_watch
   module procedure start_watch_aa, start_watch_as, start_watch_sa, start_watch_ss, start_watch_ga, start_watch_gs
end interface

interface stop_watch
   module procedure stop_watch_aa, stop_watch_as, stop_watch_sa, stop_watch_ss, stop_watch_ga, stop_watch_gs
end interface

interface reset_watch
   module procedure reset_watch_aa, reset_watch_as, reset_watch_sa, reset_watch_ss, reset_watch_ga, reset_watch_gs
end interface

interface pause_watch
   module procedure pause_watch_aa, pause_watch_as, pause_watch_sa, pause_watch_ss, pause_watch_ga, pause_watch_gs
end interface

interface end_pause_watch
   module procedure end_pause_watch_aa, end_pause_watch_as, end_pause_watch_sa, end_pause_watch_ss, &
                    end_pause_watch_ga, end_pause_watch_gs
end interface

interface read_watch
   module procedure read_watch_aa, read_watch_as, read_watch_ax, read_watch_sa, read_watch_ss, read_watch_sx
end interface

interface print_watch
   module procedure print_watch_aa, print_watch_as, print_watch_sa, print_watch_ss, print_watch_ga, print_watch_gs
end interface

interface option_stopwatch
   module procedure option_stopwatch_a, option_stopwatch_s
end interface

interface create_watchgroup
   module procedure create_watchgroup_a, create_watchgroup_s
end interface

interface join_watchgroup
   module procedure join_watchgroup_a, join_watchgroup_s
end interface

interface leave_watchgroup
   module procedure leave_watchgroup_a, leave_watchgroup_s
end interface

interface which_clocks
   module procedure which_clocks_a, which_clocks_s
end interface
$!==================================================================================================================================
$!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
$!==================================================================================================================================
contains
$!==================================================================================================================================
$!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
$!==================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file create_watch.3m_stopwatch.txt
.TH CREATE_WATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
create_watch(3f) - [M_stopwatch] creates and initializes a M_StopWatch watch (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "create_watch" "(watch, clock, name, err)"

.IP
type (watchtype), intent(OUT) ::  watch
.IP OR
type (watchtype), intent(OUT) ::  watch(:)

.IP
character(len=*), optional, intent(IN) ::  clock
.IP OR
character(len=*), intent(IN) ::  clock(:)

.IP
character(len=*), optional, intent(IN) ::  name
.IP OR
character(len=*), optional, intent(IN) ::  name(:)

.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Creates and initializes the specified clocks of the
specified watches.  In the initial state, all clocks
are not running and have the value 0.  All watches must
be created before they are used or added to a watch
group.  In Fortran 90 it is impossible to test whether
or not a watch has been created, and using a watch that
has not been created may cause the program to crash.
It is not an error to create a watch that has already
been created, however the prior information and memory
locations will be lost.  Watches should be destroyed
(see
.BR "destroy_watch" "(3))"
before they are recreated.  Also, local variable
watches should be destroyed before returning from a
subroutine, to avoid memory leaks.

One or more watches must be specified.  The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to create one watch, or an array of type
.I watchtype
to create several watches.

The optional argument
.I clock
specifies which clocks to create on the specified
watch(es).  If omitted, the current default clocks (see
.BR "option_stopwatch" "(3))"
are created.  If present,
.I clock
must be a character string containing 'cpu', 'user',
\'sys', or 'wall', or an array of such character
strings.

The optional argument
.I name
allows you to attach a name to the watch.  The name is
used when printing error messages, or when printing
clock values using
.B print_watch.
If omitted, the name of the watch is 'unnamed watch'.
If present, it must be of the same rank and dimension
as
.I watch.
Watch names are limited to 132 characters.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch(es) will not be
created.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 8
Invalid clock type.  This occurs if
.I clock
is present and one of the specified clocks is not
supported by the implementation.  See
.BR "inquiry_stopwatch" "(3)"
to determine what clocks are available.

.IP 32
Number of names is not equal to number of watches.
This occurs if the array of watch names,
.I name,
is not of the same length as the array of watches,
.I watch.

.IP 64
Character string too long.  This occurs when a watch
name has more than 132 characters.  The watch is
created, but the name is truncated to the first 132
characters.

.IP 512
Failed to allocate required memory.  Creating a watch
involves allocating memory for it.  Also, when
.B create_watch
is called with an array or group of watches, temporary
memory is allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array or group of watches.
The watches are created, but be aware that other
problems could develop as a result of the deallocate
error.

.LP

In addition to the run time diagnostics generated by
M_StopWatch, the following problems may arise:

.IP o
Since
.I watch
has intent OUT, you cannot use an array constructor as
an actual argument to construct an array of watches.
Some compilers will recognize this as a compile time
error, but will generate an obscure error message, such
as ``no specific match for generic name''.

.IP o
In Fortran 90, the character strings in an array
constructor must all have the same length.  Pad three
letter clock names with a blank on the right to make a
four character string, for example, 'cpu ', and pad
watch names so they all have the same length (within an
array constructor).

.SH EXAMPLES
type (watchtype) w1, w2(3), w3
.br
integer errcode

call create_watch(w1)
.br
call create_watch(w2, name=(/'part 1', 'part 2', 'total
\'/), err=errcode)
.br
call create_watch(w3, (/'cpu ', 'wall'/), err=errcode)

The first call creates the default clocks on a single
watch with name 'unnamed watch'.  The second call
creates the default clocks on three watches given as an
array and with names 'part 1', 'part 2', and 'total',
and returns a status code.  The third call creates one
watch with the cpu and wall clocks, the name 'unnamed
watch', and returns a status code.

.nf

   program demo_creat_watch
   ! example program starts a watch W1, stops it, and prints the results
   use,intrinsic :: iso_fortran_env, only : &
      ERROR_UNIT, INPUT_UNIT, OUTPUT_UNIT ! access computing environment
   use M_stopwatch, only : watchtype
   use M_stopwatch, only : option_stopwatch, create_watch, start_watch
   use M_stopwatch, only : stop_watch, print_watch, destroy_watch
   implicit none
   type (watchtype) w1
   character(len=:),allocatable :: cmd
   integer errcode

      cmd='hostname;sleep 3;date;pwd'

      call option_stopwatch(                                            &
         default_clock=[character(len=4) :: 'cpu','wall','user','sys'], &
         io_unit_print=ERROR_UNIT,                                      &
         io_unit_error=ERROR_UNIT)

      call create_watch(watch=w1, name='times')
      call start_watch(watch=w1)

      call execute_command_line(cmd) ! do something that takes some time

      call stop_watch(watch=w1)
      call print_watch(watch=w1, title='COMMAND:'//cmd, err=errcode)
      call destroy_watch(w1)

   end program demo_creat_watch
.fi

Expected typical output:

.nf
   buzz
   Sun Nov  4 20:56:29 EST 2018
   /home/urbanjs/V600
   COMMAND:hostname;sleep 3;date;pwd
     times:
           cpu=    0.03 user=    0.00  sys=    0.03 wall=    3.38
.fi


.SH BUGS
None known.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
join_watchgroup(3), leave_watchgroup(3),
option_stopwatch(3), pause_watch(3), print_watch(3),
read_watch(3), reset_watch(3), start_watch(3),
stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!-------------------------------------------------------------------
!                 CREATE_WATCH
!-------------------------------------------------------------------

!          -------------------
subroutine create_watch_actual(watch,clock,name,err)
!          -------------------

!----------------------------------------------------
! This routine creates the specified watches with the specified clocks.
! You can NOT use it to add a clock to an already created watch.  This is
! because I cannot use "allocated" to see if the watch was already created,
! and then know whether to allocate or just add a clock.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type (watch_pointer), intent(out), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
character(len=*), intent(in), dimension(:) :: name
integer, optional, intent(out) :: err

!----------------------------------------------------

!----------------------------------------------------
! Local variables:

type (watch_actual), pointer :: the_watch
integer :: i, erralloc
character(len=NAME_LEN) :: tname

!----------------------------------------------------

!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=0
end if

! set default clocks to be all available clocks.  This only needs to be done
! once, which can be checked by seeing if default_clocks has been allocated.

if (.not. allocated(default_clocks)) then
   call option_stopwatch(default_clock=(/"cpu ","user","sys ","wall"/),err=err)
end if

! set the flags for which clocks to create

call which_clocks(clock,"create_watch",err)

! loop through the watches

do i=1,ubound(watch,dim=1)

   allocate(watch(i)%ptr,stat=erralloc)
   if (erralloc > 0) then
      call err_handler_watch(ERR_ALLOC,"create_watch","", "Watch not created.",err)
   else
      the_watch => watch(i)%ptr

      if (len_trim(name(i)) > 132) then
         call err_handler_watch(ERR_C2LONG,"create_watch",name(i), "Name shortened to 132 characters.",err)
         tname = name(i)(1:132)
         the_watch = watch_actual(tname,status_type(OMITTED,OMITTED,OMITTED, &
                                  OMITTED),clocks(0.0,0.0,0.0,0),clocks(0.0,0.0,0.0,0))
      else

         the_watch = watch_actual(name(i),status_type(OMITTED,OMITTED,OMITTED, &
                                  OMITTED),clocks(0.0,0.0,0.0,0),clocks(0.0,0.0,0.0,0))
      end if

      if (do_cpu) then
         the_watch%status%cpu = STOPPED
      end if
      if (do_user) then
         the_watch%status%user = STOPPED
      end if
      if (do_sys ) then
         the_watch%status%sys  = STOPPED
      end if
      if (do_wall) then
         the_watch%status%wall = STOPPED
      end if

   end if
end do

end subroutine create_watch_actual
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
! Alternate forms for create_watch
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine create_watch_aa(watch,clock,name,err)
!          ---------------
type (watchtype), intent(out), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
character(len=*), optional, intent(in), dimension(:) :: name
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
character(len=NAME_LEN), allocatable, dimension(:) :: no_name
integer :: erralloc,i
if (present(name)) then
   if (size(watch) /= size(name)) then
      call err_handler_watch(ERR_NAMES,"create_watch","", "Watches not created.",err)
      return
   end if
end if
allocate(watches(size(watch)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"create_watch","", "Watches not created.",err)
else
   if (present(name)) then
      call create_watch_actual(watches,clock,name,err)
   else
      allocate(no_name(size(watch)),stat=erralloc)
      if (erralloc > 0) then
         call err_handler_watch(ERR_ALLOC,"create_watch","", "Watches not created.",err)
      else
         no_name = "unnamed watch"
         call create_watch_actual(watches,clock,no_name,err)
         deallocate(no_name,stat=erralloc)
         if (erralloc > 0) then
            call err_handler_watch(ERR_DEALLOC,"create_watch","", "Watches created, but further problems may develop.",err)
         end if
      end if
   end if
end if
do i=1,size(watch)
   watch(i)%ptr => watches(i)%ptr
end do
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"create_watch","", "Watches created, but further problems may develop.",err)
end if

end subroutine create_watch_aa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine create_watch_as(watch,clock,name,err)
!          --------------
type (watchtype), intent(out), dimension(:) :: watch
character(len=*), optional, intent(in) :: clock
character(len=*), optional, intent(in), dimension(:) :: name
integer, optional, intent(out) :: err

if (present(clock)) then
   call create_watch_aa(watch, (/clock/),name,err)
else
   if (.not. allocated(default_clocks)) then
      call option_stopwatch(default_clock=(/"cpu ","user","sys ","wall"/),err=err)
   end if
   call create_watch_aa(watch,default_clocks,name,err)
end if

end subroutine create_watch_as
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine create_watch_sa(watch,clock,name,err)
!          --------------
type (watchtype), intent(out) :: watch
character(len=*), intent(in), dimension(:) :: clock
character(len=*), optional, intent(in) :: name
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches

if (present(name)) then
   call create_watch_actual(watches,clock,(/name/),err)
else
   call create_watch_actual(watches,clock,(/"unnamed watch"/),err)
end if

watch%ptr => watches(1)%ptr

end subroutine create_watch_sa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine create_watch_ss(watch,clock,name,err)
!          --------------
type (watchtype), intent(out) :: watch
character(len=*), optional, intent(in) :: clock
character(len=*), optional, intent(in) :: name
integer, optional,intent(out) :: err
type (watch_pointer), dimension(1) :: watches
if (present(name)) then
   if (present(clock)) then
      call create_watch_actual(watches, (/clock/),(/name/),err)
   else
      if (.not. allocated(default_clocks)) then
         call option_stopwatch(default_clock=(/"cpu ","user","sys ","wall"/),err=err)
      end if
      call create_watch_actual(watches,default_clocks,(/name/),err)
   end if
else
   if (present(clock)) then
      call create_watch_actual(watches, (/clock/),(/"unnamed watch"/),err)
   else
      if (.not. allocated(default_clocks)) then
         call option_stopwatch(default_clock=(/"cpu ","user","sys ","wall"/),err=err)
      end if
      call create_watch_actual(watches,default_clocks,(/"unnamed watch"/),err)
   end if
end if
watch%ptr => watches(1)%ptr

end subroutine create_watch_ss
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file destroy_watch.3m_stopwatch.txt
.TH DESTROY_WATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
destroy_watch(3f) - [M_stopwatch] destroys a M_StopWatch watch (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "destroy_watch" "(watch, clock, err)"

.IP
type (watchtype), intent(INOUT) ::  watch
.IP OR
type (watchtype), intent(INOUT) ::  watch(:)

.IP
character(len=*), optional, intent(IN) ::  clock
.IP OR
character(len=*), intent(IN) ::  clock(:)

.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Destroys the specified clocks of the specified watches.
If the watch has no remaining clocks after the
specified clocks are destroyed, then the watch is
destroyed and associated memory freed.  To avoid memory
leaks, watches should be destroyed when no longer
useful, before being recreated, and before returning
from a subroutine in which the watch is a local
variable.

One or more watches must be specified.  The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to destroy one watch, or an array of type
.I watchtype
to destroy several watches.

The optional argument
.I clock
specifies which clocks to destroy on the specified
watch(es).  If omitted, the current default clocks (see
.BR "option_stopwatch" "(3))"
are destroyed.  If present,
.I clock
must be a character string containing 'cpu', 'user',
\'sys', or 'wall', or an array of such character
strings.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch(es) will not be
destroyed.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1
Watch needs to be created.  This error occurs if you
attempt to destroy a watch that has already been
destroyed.  The watch must first be created again.  See
also the comment about watches that have never been
created in the BUGS section.
.IP 8
Invalid clock type.  This occurs if
.I clock
is present and one of the specified clocks is not
supported by the implementation.  See
.BR "inquiry_stopwatch" "(3)"
to determine what clocks are available.

.IP 512
Failed to allocate required memory.  When
.B destroy_watch
is called with an array or group of watches, temporary
memory is allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
the memory for the watch or temporary memory used for
an array or group of watches.  The watches are
destroyed, but be aware that other problems could
develop as a result of the deallocate error.

.LP

In addition to the run time diagnostics generated by
M_StopWatch, the following problems may arise:

.IP o
Since
.I watch
has intent OUT, you cannot use an array constructor as
an actual argument to construct an array of watches.
Some compilers will recognize this as a compile time
error, but will generate an obscure error message, such
as ``no specific match for generic name''.

.IP o
In Fortran 90, the character strings in an array
constructor must all have the same length.  Pad three
letter clock names with a blank on the right to make a
four character string, for example, 'cpu '.

.SH EXAMPLES
type (watchtype) w1, w2(3)
.br
integer errcode

call destroy_watch(w1)
.br
call destroy_watch(w2, (/'sys ', 'user'/), err=errcode)

The first call destroys the default clocks on a single
watch.  Assuming the default clocks have not changed
since the watch was created, the watch will be
destroyed.  The second call destroys the sys and user
clocks on three watches given as an array and returns a
status code.  Assuming the watch also had the cpu or
wall clock, the watches are not destroyed.

.SH BUGS
It cannot be determined whether or not a watch variable
or watch group has been created (passed as an argument
to
.B create_watch
or
.BR "create_watchgroup" ")."
If a watch or watch group that has never been created
is passed into
.B destroy_watch,
it might generate a Fortran error due to passing a
pointer with undefined association status to the
Fortran intrinsic function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3),
destroy_watchgroup(3), end_pause_watch(3),
inquiry_stopwatch(3), join_watchgroup(3),
leave_watchgroup(3), option_stopwatch(3),
pause_watch(3), print_watch(3), read_watch(3),
reset_watch(3), start_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!                 DESTROY_WATCH
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!          -----------------------
subroutine destroy_watch_actual(watch,clock,err)
character(len=*),parameter :: ident_destroy_watch='M_stopwatch::destroy_watch(3f): destroys a M_StopWatch watch'
!          -----------------------

!----------------------------------------------------
! This routine destroys the specified clocks of the specified watches
! and destroys the watch if there are no remaining clocks.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type (watch_pointer), intent(in out), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err

!----------------------------------------------------
!----------------------------------------------------
! Local variables:

type (watch_actual), pointer :: the_watch
integer :: i, erralloc

!----------------------------------------------------
!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=0
end if

! set the flags for which clocks to destroy

call which_clocks(clock,"destroy_watch",err)

! loop through the watches

do i=1,ubound(watch,dim=1)

   the_watch => watch(i)%ptr
   if (.not. associated(the_watch)) then
      call err_handler_watch(ERR_CREATE,"destroy_watch","", "Watch not destroyed.",err)
   else

      if (do_cpu) then
         the_watch%status%cpu = OMITTED
      end if
      if (do_user) then
         the_watch%status%user = OMITTED
      end if
      if (do_sys ) then
         the_watch%status%sys  = OMITTED
      end if
      if (do_wall) then
         the_watch%status%wall = OMITTED
      end if

      if( the_watch%status%cpu == OMITTED .and. the_watch%status%user == OMITTED &
      .and. the_watch%status%sys == OMITTED .and. the_watch%status%wall == OMITTED) then
         deallocate(watch(i)%ptr,stat=erralloc)
         if (erralloc > 0) then
            call err_handler_watch(ERR_DEALLOC,"destroy_watch","", "Watch destroyed, but further problems may develop.",err)
         end if
      end if
   end if
end do

end subroutine destroy_watch_actual
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
! Alternate forms for destroy_watch
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine destroy_watch_aa(watch,clock,err)
!          ---------------
type (watchtype), intent(in out), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
integer :: erralloc,i
allocate(watches(size(watch)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"destroy_watch","", "Watches not destroyed.",err)
else
   do i=1,size(watch)
      watches(i)%ptr => watch(i)%ptr
   end do
   call destroy_watch_actual(watches,clock,err)
end if
do i=1,size(watch)
   watch(i)%ptr => watches(i)%ptr
end do
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"destroy_watch","", "Watches destroyed, but further problems may develop.",err)
end if

end subroutine destroy_watch_aa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine destroy_watch_as(watch,clock,err)
!          --------------
type (watchtype), intent(in out), dimension(:) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
if (present(clock)) then
   call destroy_watch_aa(watch, (/clock/),err)
else
   call destroy_watch_aa(watch,default_clocks,err)
end if

end subroutine destroy_watch_as
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine destroy_watch_sa(watch,clock,err)
!          --------------
type (watchtype), intent(in out) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
call destroy_watch_actual(watches,clock,err)
watch%ptr => watches(1)%ptr

end subroutine destroy_watch_sa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine destroy_watch_ss(watch,clock,err)
!          --------------
type (watchtype), intent(in out) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional,intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
if (present(clock)) then
   call destroy_watch_actual(watches, (/clock/),err)
else
   call destroy_watch_actual(watches,default_clocks,err)
end if
watch%ptr => watches(1)%ptr

end subroutine destroy_watch_ss
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file start_watch.3m_stopwatch.txt
.TH START_WATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
start_watch(3f) - [M_stopwatch] starts a M_StopWatch watch (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "start_watch" "(watch, clock, err)"

.IP
type (watchtype), intent(IN) ::  watch
.IP OR
type (watchtype), intent(IN) ::  watch(:)
.IP OR
type (watchgroup), intent(IN) ::  watch

.IP
character(len=*), optional, intent(IN) ::  clock
.IP OR
character(len=*), intent(IN) ::  clock(:)

.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Starts the specified clocks of the specified watches.
Any time previously accumulated in the clock is NOT
cleared before starting.  (Use
.B reset_watch
to clear accumulated time.)

One or more watches must be specified.  The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to start one watch, an array of type
.I watchtype
to start several watches, or a variable of type
.I watchgroup
(see
.BR "M_stopwatch" "(3))"
to start the watches in a group.

The optional argument
.I clock
specifies which clocks to start on the specified
watch(es).  If omitted, the current default clocks (see
.BR "option_stopwatch" "(3))"
are started.  If present,
.I clock
must be a character string containing 'cpu', 'user',
\'sys', or 'wall', or an array of such character
strings.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch(es) will not be
started.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1
Watch needs to be created.  This error occurs if you
attempt to start a watch that has been destroyed.  The
watch must first be created again.  See also the
comment about watches that have never been created in
the BUGS section.

.IP 2
Watch is in the wrong state for this operation.  This
occurs when you attempt to start a watch that is
currently running or paused.

.IP 4
Watch is in an unknown state.  This occurs if M_StopWatch
does not recognize the state (running, stopped, etc.)
that the watch is in.  This error should not occur, and
indicates an internal bug in M_StopWatch.

.IP 8
Invalid clock type.  This occurs if
.I clock
is present and one of the specified clocks is not
supported by the implementation.  See
.BR "inquiry_stopwatch" "(3)"
to determine what clocks are available.

.IP 512
Failed to allocate required memory.  When
.B start_watch
is called with an array or group of watches, temporary
memory is allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array or group of watches.
The watches are started, but be aware that other
problems could develop as a result of the deallocate
error.

.LP

In addition to the run time diagnostics generated by
M_StopWatch, the following problems may arise:

.IP o
In Fortran 90, the character strings in an array
constructor must all have the same length.  Pad three
letter clock names with a blank on the right to make a
four character string, for example, 'cpu '.

.SH EXAMPLES
type (watchtype) w1, w2(3)
.br
type (watchgroup) g1
.br
integer errcode

call start_watch(w1)
.br
call start_watch(w2, err=errcode)
.br
call start_watch(g1, (/'cpu ', 'wall'/), errcode)

The first call starts the default clocks on a single
watch.  The second call starts the default clocks on
three watches given as an array and returns an status
code.  The third call starts the cpu and wall clocks on
the watches in the group
.I g1,
and returns a status code.

.SH BUGS
It cannot be determined whether or not a watch variable
or watch group has been created (passed as an argument
to
.B create_watch
or
.BR "create_watchgroup" ")."
If a watch or watch group that has never been created
is passed into
.B start_watch,
it might generate a Fortran error due to passing a
pointer with undefined association status to the
Fortran intrinsic function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
join_watchgroup(3), leave_watchgroup(3),
option_stopwatch(3), pause_watch(3), print_watch(3),
read_watch(3), reset_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!                 START_WATCH
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine start_watch_actual(watch,clock,err)

character(len=*),parameter :: ident_start_watch='M_stopwatch::start_watch(3f): starts the specified clocks of the specified watches'

!----------------------------------------------------
! Dummy arguments

type (watch_pointer), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err

!----------------------------------------------------

!----------------------------------------------------
! Local variables:

type (watch_actual), pointer :: the_watch
real :: readcpu,readusr,readsys
integer :: i

!----------------------------------------------------

!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=0
end if

! set the flags for which clocks to start

call which_clocks(clock,"start_watch",err)

! loop through the watches

do i=1,ubound(watch,dim=1)

   the_watch => watch(i)%ptr
   if (.not. associated(the_watch)) then
      call err_handler_watch(ERR_CREATE,"start_watch","", "Watch not started.",err)
   else

! start each flagged clock for this watch

      call system_cpu_time(readcpu,readusr,readsys)
      if (do_cpu) then
         select case (the_watch%status%cpu)
            case (STOPPED)
               the_watch%last_read%cpu = readcpu
               the_watch%status%cpu = RUNNING
            case (RUNNING, PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"start_watch",the_watch%name, "Watch's cpu clock not started.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"start_watch",the_watch%name, "Watch's cpu clock not started.",err)
         end select
      end if
      if (do_user) then
         select case (the_watch%status%user)
            case (STOPPED)
               the_watch%last_read%user = readusr
               the_watch%status%user = RUNNING
            case (RUNNING, PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"start_watch",the_watch%name, "Watch's user clock not started.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"start_watch",the_watch%name, "Watch's user clock not started.",err)
         end select
      end if
      if (do_sys) then
         select case (the_watch%status%sys)
            case (STOPPED)
               the_watch%last_read%sys = readsys
               the_watch%status%sys = RUNNING
            case (RUNNING, PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"start_watch",the_watch%name, "Watch's sys clock not started.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"start_watch",the_watch%name, "Watch's sys clock not started.",err)
         end select
      end if
      if (do_wall) then
         select case (the_watch%status%wall)
            case (STOPPED)
               call system_clock(count=the_watch%last_read%wall)
               the_watch%status%wall = RUNNING
            case (RUNNING, PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"start_watch",the_watch%name, "Watch's wall clock not started.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"start_watch",the_watch%name, "Watch's wall clock not started.",err)
         end select
      end if
   end if
end do

end subroutine start_watch_actual
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
! Alternate forms for start_watch
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine start_watch_ga(watch,clock,err)
!          --------------
type (watchgroup), intent(in out) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
type (watch_list), pointer :: list_entry
integer :: erralloc, i
if (associated(watch%head)) then
   allocate(watches(watch%wgsize),stat=erralloc)
   if (erralloc > 0) then
      call err_handler_watch(ERR_ALLOC,"start_watch","", "Watches not started.",err)
   else
      list_entry => watch%head
      i = 0
      do
         if (.not. associated(list_entry)) then
            exit
         end if
         i=i+1
         watches(i)%ptr => list_entry%this_watch
         list_entry => list_entry%next
      end do
      call start_watch_actual(watches,clock,err)
      deallocate(watches,stat=erralloc)
      if (erralloc > 0) then
         call err_handler_watch(ERR_DEALLOC,"start_watch","", "Watches started, but further problems may develop.",err)
      end if
   end if
else
   if (present(err)) then
      err = 0
   end if
end if

end subroutine start_watch_ga
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine start_watch_gs(watch,clock,err)
!          --------------
type (watchgroup), intent(in out) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
if (present(clock)) then
   call start_watch_ga(watch, (/clock/),err)
else
   call start_watch_ga(watch,default_clocks,err)
end if

end subroutine start_watch_gs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine start_watch_aa(watch,clock,err)
!          --------------
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
integer :: erralloc,i
allocate(watches(size(watch)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"start_watch","", "Watches not started.",err)
else
   do i=1,size(watch)
      watches(i)%ptr => watch(i)%ptr
   end do
   call start_watch_actual(watches,clock,err)
end if
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"start_watch","", "Watches started, but further problems may develop.",err)
end if

end subroutine start_watch_aa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine start_watch_as(watch,clock,err)
!          --------------
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
if (present(clock)) then
   call start_watch_aa(watch, (/clock/),err)
else
   call start_watch_aa(watch,default_clocks,err)
end if

end subroutine start_watch_as
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine start_watch_sa(watch,clock,err)
!          --------------
type (watchtype), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
call start_watch_actual(watches,clock,err)

end subroutine start_watch_sa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine start_watch_ss(watch,clock,err)
!          --------------
type (watchtype), intent(in) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
if (present(clock)) then
   call start_watch_actual(watches, (/clock/),err)
else
   call start_watch_actual(watches,default_clocks,err)
end if

end subroutine start_watch_ss
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file stop_watch.3m_stopwatch.txt
.TH STOP_WATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
stop_watch(3f) - [M_stopwatch] stops a M_StopWatch watch (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "stop_watch" "(watch, clock, err)"

.IP
type (watchtype), intent(IN) ::  watch
.IP OR
type (watchtype), intent(IN) ::  watch(:)
.IP OR
type (watchgroup), intent(IN) ::  watch

.IP
character(len=*), optional, intent(IN) ::  clock
.IP OR
character(len=*), intent(IN) ::  clock(:)

.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Stops the specified clocks of the specified watches.

One or more watches must be specified.  The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to stop one watch, an array of type
.I watchtype
to stop several watches, or a variable of type
.I watchgroup
(see
.BR "M_stopwatch" "(3))"
to stop the watches in a group.

The optional argument
.I clock
specifies which clocks to stop on the specified
watch(es).  If omitted, the current default clocks (see
.BR "option_stopwatch" "(3))"
are stopped.  If present,
.I clock
must be a character string containing 'cpu', 'user',
\'sys', or 'wall', or an array of such character
strings.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch(es) will not be
stopped.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1
Watch needs to be created.  This error occurs if you
attempt to stop a watch that has been destroyed.  The
watch must first be created again.  See also the
comment about watches that have never been created in
the BUGS section.

.IP 2
Watch is in the wrong state for this operation.  This
occurs when you attempt to stop a watch that is
currently paused or not running.

.IP 4
Watch is in an unknown state.  This occurs if M_StopWatch
does not recognize the state (running, stopped, etc.)
that the watch is in.  This error should not occur, and
indicates an internal bug in M_StopWatch.

.IP 8
Invalid clock type.  This occurs if
.I clock
is present and one of the specified clocks is not
supported by the implementation.  See
.BR "inquiry_stopwatch" "(3)"
to determine what clocks are available.

.IP 512
Failed to allocate required memory.  When
.B stop_watch
is called with an array or group of watches, temporary
memory is allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array or group of watches.
The watches are stopped, but be aware that other
problems could develop as a result of the deallocate
error.

.LP

In addition to the run time diagnostics generated by
M_StopWatch, the following problems may arise:

.IP o
In Fortran 90, the character strings in an array
constructor must all have the same length.  Pad three
letter clock names with a blank on the right to make a
four character string, for example, 'cpu '.

.SH EXAMPLES
type (watchtype) w1, w2(3)
.br
type (watchgroup) g1
.br
integer errcode

call stop_watch(w1)
.br
call stop_watch(w2, err=errcode)
.br
call stop_watch(g1, (/'cpu ', 'wall'/), errcode)

The first call stops the default clocks on a single
watch.  The second call stops the default clocks on
three watches given as an array and returns a status
code.  The third call stops the cpu and wall clocks on
the watches in the group
.I g1,
and returns a status code.

.SH BUGS
It cannot be determined whether or not a watch variable
or watch group has been created (passed as an argument
to
.B create_watch
or
.BR "create_watchgroup" ")."
If a watch or watch group that has never been created
is passed into
.B stop_watch,
it might generate a Fortran error due to passing a
pointer with undefined association status to the
Fortran intrinsic function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
join_watchgroup(3), leave_watchgroup(3),
option_stopwatch(3), pause_watch(3), print_watch(3),
read_watch(3), reset_watch(3), start_watch(3),
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!                 STOP_WATCH
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine stop_watch_actual(watch,clock,err)

character(len=*),parameter :: ident_stop_watch='M_stopwatch::stop_watch(3f): stops the specified clocks of the specified watches'

!----------------------------------------------------
! Dummy arguments

type (watch_pointer), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err

!----------------------------------------------------

!----------------------------------------------------
! Local variables:

type (watch_actual), pointer :: the_watch
real :: diff,readcpu,readusr,readsys
integer :: i,new_read,r,m,idiff

!----------------------------------------------------

!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=0
end if

! set the flags for which clocks to stop

call which_clocks(clock,"stop_watch",err)

! loop through the watches

do i=1,ubound(watch,dim=1)

   the_watch => watch(i)%ptr
   if (.not. associated(the_watch)) then
      call err_handler_watch(ERR_CREATE,"stop_watch","", "Watch not stopped.",err)
   else

! stop each flagged clock for this watch

      call system_cpu_time(readcpu,readusr,readsys)
      if (do_cpu) then
         select case (the_watch%status%cpu)
            case (STOPPED, PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"stop_watch",the_watch%name, "Watch's cpu clock not stopped.",err)
            case (RUNNING)
               diff = readcpu - the_watch%last_read%cpu
               the_watch%elapsed%cpu = the_watch%elapsed%cpu + diff
               the_watch%status%cpu = STOPPED
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"stop_watch",the_watch%name, "Watch's cpu clock not stopped.",err)
         end select
      end if
      if (do_user) then
         select case (the_watch%status%user)
            case (STOPPED, PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"stop_watch",the_watch%name, "Watch's user clock not stopped.",err)
            case (RUNNING)
               diff = readusr - the_watch%last_read%user
               the_watch%elapsed%user = the_watch%elapsed%user + diff
               the_watch%status%user = STOPPED
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"stop_watch",the_watch%name, "Watch's user clock not stopped.",err)
         end select
      end if
      if (do_sys) then
         select case (the_watch%status%sys)
            case (STOPPED, PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"stop_watch",the_watch%name, "Watch's sys clock not stopped.",err)
            case (RUNNING)
               diff = readsys - the_watch%last_read%sys
               the_watch%elapsed%sys = the_watch%elapsed%sys + diff
               the_watch%status%sys = STOPPED
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"stop_watch",the_watch%name, "Watch's sys clock not stopped.",err)
         end select
      end if
      if (do_wall) then
         select case (the_watch%status%wall)
            case (STOPPED, PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"stop_watch",the_watch%name, "Watch's wall clock not stopped.",err)
            case (RUNNING)
               call system_clock(count=new_read,count_rate=r,count_max=m)
               if (r==0) then
                  idiff = 0
               else
                  idiff = new_read-the_watch%last_read%wall
                  if (idiff < 0) then
                     idiff = idiff + m ! clock cycled
                  end if
               end if
               the_watch%elapsed%wall = the_watch%elapsed%wall + idiff
               the_watch%status%wall = STOPPED
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"stop_watch",the_watch%name, "Watch's wall clock not stopped.",err)
         end select
      end if
   end if
end do

end subroutine stop_watch_actual
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
! Alternate forms for stop_watch
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine stop_watch_ga(watch,clock,err)
!          -------------
type (watchgroup), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
type (watch_list), pointer :: list_entry
integer :: erralloc, i
if (associated(watch%head)) then
   allocate(watches(watch%wgsize),stat=erralloc)
   if (erralloc > 0) then
      call err_handler_watch(ERR_ALLOC,"stop_watch","", "Watches not stopped.",err)
   else
      list_entry => watch%head
      i = 0
      do
         if (.not. associated(list_entry)) then
            exit
         end if
         i=i+1
         watches(i)%ptr => list_entry%this_watch
         list_entry => list_entry%next
      end do
      call stop_watch_actual(watches,clock,err)
      deallocate(watches,stat=erralloc)
      if (erralloc > 0) then
         call err_handler_watch(ERR_DEALLOC,"stop_watch","", "Watches stopped, but further problems may develop.",err)
      end if
   end if
else
   if (present(err)) then
      err = 0
   end if
end if
end subroutine stop_watch_ga
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine stop_watch_gs(watch,clock,err)
!          -------------
type (watchgroup), intent(in) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
if (present(clock)) then
   call stop_watch_ga(watch, (/clock/),err)
else
   call stop_watch_ga(watch,default_clocks,err)
end if
end subroutine stop_watch_gs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine stop_watch_aa(watch,clock,err)
!          -------------
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
integer :: erralloc,i
allocate(watches(size(watch)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"stop_watch","", "Watches not stopped.",err)
else
   do i=1,size(watch)
      watches(i)%ptr => watch(i)%ptr
   end do
   call stop_watch_actual(watches,clock,err)
end if
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"stop_watch","", "Watches stopped, but further problems may develop.",err)
end if
end subroutine stop_watch_aa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine stop_watch_as(watch,clock,err)
!          -------------
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
if (present(clock)) then
   call stop_watch_aa(watch, (/clock/),err)
else
   call stop_watch_aa(watch,default_clocks,err)
end if
end subroutine stop_watch_as
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine stop_watch_sa(watch,clock,err)
!          -------------
type (watchtype), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
call stop_watch_actual(watches,clock,err)
end subroutine stop_watch_sa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine stop_watch_ss(watch,clock,err)
!          -------------
type (watchtype), intent(in) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
if (present(clock)) then
   call stop_watch_actual(watches, (/clock/),err)
else
   call stop_watch_actual(watches,default_clocks,err)
end if
end subroutine stop_watch_ss
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file reset_watch.3m_stopwatch.txt
.TH RESET_WATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
reset_watch(3f) - [M_stopwatch] resets a M_StopWatch watch to 0.0 (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "reset_watch" "(watch, clock, err)"

.IP
type (watchtype), intent(IN) ::  watch
.IP OR
type (watchtype), intent(IN) ::  watch(:)
.IP OR
type (watchgroup), intent(IN) ::  watch

.IP
character(len=*), optional, intent(IN) ::  clock
.IP OR
character(len=*), intent(IN) ::  clock(:)

.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Resets the specified clocks of the specified watches to
0.  Clocks can be reset regardless of whether they are
running or not.

One or more watches must be specified.  The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to reset one watch, an array of type
.I watchtype
to reset several watches, or a variable of type
.I watchgroup
(see
.BR "M_stopwatch" "(3))"
to reset the watches in a group.

The optional argument
.I clock
specifies which clocks to reset on the specified
watch(es).  If omitted, the current default clocks (see
.BR "option_stopwatch" "(3))"
are reset.  If present,
.I clock
must be a character string containing 'cpu', 'user',
\'sys', or 'wall', or an array of such character
strings.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch(es) will not be reset.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1
Watch needs to be created.  This error occurs if you
attempt to reset a watch that has been destroyed.  The
watch must first be created again.  See also the
comment about watches that have never been created in
the BUGS section.

.IP 2
Watch is in the wrong state for this operation.  This
occurs when you attempt to reset a watch that is
currently paused.

.IP 4
Watch is in an unknown state.  This occurs if M_StopWatch
does not recognize the state (running, stopped, etc.)
that the watch is in.  This error should not occur, and
indicates an internal bug in M_StopWatch.

.IP 8
Invalid clock type.  This occurs if
.I clock
is present and one of the specified clocks is not
supported by the implementation.  See
.BR "inquiry_stopwatch" "(3)"
to determine what clocks are available.

.IP 512
Failed to allocate required memory.  When
.B reset_watch
is called with an array or group of watches, temporary
memory is allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array or group of watches.
The watches are reset, but be aware that other problems
could develop as a result of the deallocate error.

.LP

In addition to the run time diagnostics generated by
M_StopWatch, the following problems may arise:

.IP o
In Fortran 90, the character strings in an array
constructor must all have the same length.  Pad three
letter clock names with a blank on the right to make a
four character string, for example, 'cpu '.

.SH EXAMPLES
type (watchtype) w1, w2(3)
.br
type (watchgroup) g1
.br
integer errcode

call reset_watch(w1)
.br
call reset_watch(w2, err=errcode)
.br
call reset_watch(g1, (/'cpu ', 'wall'/), errcode)

The first call resets the default clocks on a single
watch.  The second call resets the default clocks on
three watches given as an array and returns a status
code.  The third call resets the cpu and wall clocks on
the watches in the group
.I g1,
and returns a status code.

.SH BUGS
It cannot be determined whether or not a watch variable
or watch group has been created (passed as an argument
to
.B create_watch
or
.BR "create_watchgroup" ")."
If a watch or watch group that has never been created
is passed into
.B reset_watch,
it might generate a Fortran error due to passing a
pointer with undefined association status to the
Fortran intrinsic function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
join_watchgroup(3), leave_watchgroup(3),
option_stopwatch(3), pause_watch(3), print_watch(3),
read_watch(3), start_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!-------------------------------------------------------------------
!                 RESET_WATCH
!-------------------------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine reset_watch_actual(watch,clock,err)
!          ------------------
character(len=*),parameter :: ident_reset_watch='M_stopwatch::reset_watch(3f): resets a M_StopWatch watch to 0.0'

!----------------------------------------------------
! This routine resets the specified clocks of the specified watches to 0.0
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type (watch_pointer), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err

!----------------------------------------------------
!----------------------------------------------------
! Local variables:
type (watch_actual), pointer :: the_watch
real :: readcpu,readusr,readsys
integer :: i
!----------------------------------------------------
!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=0
end if

! set the flags for which clocks to reset

call which_clocks(clock,"reset_watch",err)

! loop through the watches

do i=1,ubound(watch,dim=1)

   the_watch => watch(i)%ptr
   if (.not. associated(the_watch)) then
      call err_handler_watch(ERR_CREATE,"reset_watch","", "Watch not reset.",err)
   else

! reset each flagged clock for this watch

      call system_cpu_time(readcpu,readusr,readsys)
      if (do_cpu) then
         select case (the_watch%status%cpu)
            case (STOPPED)
               the_watch%elapsed%cpu = 0.0
            case (RUNNING)
               the_watch%elapsed%cpu = 0.0
               the_watch%last_read%cpu = readcpu
            case (PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"reset_watch",the_watch%name, "Watch's cpu clock not reset.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"reset_watch",the_watch%name, "Watch's cpu clock not reset.",err)
         end select
      end if
      if (do_user) then
         select case (the_watch%status%user)
            case (STOPPED)
               the_watch%elapsed%user = 0.0
            case (RUNNING)
               the_watch%elapsed%user = 0.0
               the_watch%last_read%user = readusr
            case (PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"reset_watch",the_watch%name, "Watch's user clock not reset.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"reset_watch",the_watch%name, "Watch's user clock not reset.",err)
         end select
      end if
      if (do_sys) then
         select case (the_watch%status%sys)
            case (STOPPED)
               the_watch%elapsed%sys = 0.0
            case (RUNNING)
               the_watch%elapsed%sys = 0.0
               the_watch%last_read%sys = readsys
            case (PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"reset_watch",the_watch%name, "Watch's sys clock not reset.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"reset_watch",the_watch%name, "Watch's sys clock not reset.",err)
         end select
      end if
      if (do_wall) then
         select case (the_watch%status%wall)
            case (STOPPED)
               the_watch%elapsed%wall = 0
            case (RUNNING)
               the_watch%elapsed%wall = 0
               call system_clock(count=the_watch%last_read%wall)
            case (PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"reset_watch",the_watch%name, "Watch's wall clock not reset.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"reset_watch",the_watch%name, "Watch's wall clock not reset.",err)
         end select
      end if
   end if
end do

end subroutine reset_watch_actual
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
! Alternate forms for reset_watch
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine reset_watch_ga(watch,clock,err)

type (watchgroup), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
type (watch_list), pointer :: list_entry
integer :: erralloc, i

if (associated(watch%head)) then
   allocate(watches(watch%wgsize),stat=erralloc)
   if (erralloc > 0) then
      call err_handler_watch(ERR_ALLOC,"reset_watch","", "Watches not reset.",err)
   else
      list_entry => watch%head
      i = 0
      do
         if (.not. associated(list_entry)) then
            exit
         end if
         i=i+1
         watches(i)%ptr => list_entry%this_watch
         list_entry => list_entry%next
      end do
      call reset_watch_actual(watches,clock,err)
      deallocate(watches,stat=erralloc)
      if (erralloc > 0) then
         call err_handler_watch(ERR_DEALLOC,"reset_watch","", "Watches reset, but further problems may develop.",err)
      end if
   end if
else
   if (present(err)) then
      err = 0
   end if
end if
end subroutine reset_watch_ga
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine reset_watch_gs(watch,clock,err)

type (watchgroup), intent(in) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
if (present(clock)) then
   call reset_watch_ga(watch, (/clock/),err)
else
   call reset_watch_ga(watch,default_clocks,err)
end if
end subroutine reset_watch_gs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine reset_watch_aa(watch,clock,err)
!          --------------
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
integer :: erralloc,i
allocate(watches(size(watch)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"reset_watch","", "Watches not reset.",err)
else
   do i=1,size(watch)
      watches(i)%ptr => watch(i)%ptr
   end do
   call reset_watch_actual(watches,clock,err)
end if
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"reset_watch","", "Watches reset, but further problems may develop.",err)
end if
end subroutine reset_watch_aa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine reset_watch_as(watch,clock,err)
!          --------------
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
if (present(clock)) then
   call reset_watch_aa(watch, (/clock/),err)
else
   call reset_watch_aa(watch,default_clocks,err)
end if
end subroutine reset_watch_as
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine reset_watch_sa(watch,clock,err)
!          --------------
type (watchtype), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
call reset_watch_actual(watches,clock,err)
end subroutine reset_watch_sa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine reset_watch_ss(watch,clock,err)
!          --------------
type (watchtype), intent(in) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
if (present(clock)) then
   call reset_watch_actual(watches, (/clock/),err)
else
   call reset_watch_actual(watches,default_clocks,err)
end if
end subroutine reset_watch_ss
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file pause_watch.3m_stopwatch.txt
.TH PAUSE_WATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
pause_watch(3f) - [M_stopwatch] pauses a M_StopWatch watch (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "pause_watch" "(watch, clock, err)"

.IP
type (watchtype), intent(IN) ::  watch
.IP OR
type (watchtype), intent(IN) ::  watch(:)
.IP OR
type (watchgroup), intent(IN) ::  watch

.IP
character(len=*), optional, intent(IN) ::  clock
.IP OR
character(len=*), intent(IN) ::  clock(:)

.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Pauses the specified clocks of the specified watches.
This is useful when you want to temporarily stop the
clocks to avoid timing a small segment of code, for
example printed output or graphics, but do not know
which watches or clocks are running.  When
.B pause_watch
is called, the information about which of the clocks
were running is maintained, so that a subsequent call
to
.B end_pause_watch
will restart only those clocks that were running.
One or more watches must be specified.  The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to pause one watch, an array of type
.I watchtype
to pause several watches, or a variable of type
.I watchgroup
(see
.BR "M_stopwatch" "(3))"
to pause the watches in a group.

The optional argument
.I clock
specifies which clocks to pause on the specified
watch(es).  If omitted, the current default clocks (see
.BR "option_stopwatch" "(3))"
are paused.  If present,
.I clock
must be a character string containing 'cpu', 'user',
\'sys', or 'wall', or an array of such character
strings.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch(es) will not be
paused.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1
Watch needs to be created.  This error occurs if you
attempt to pause a watch that has been destroyed.  The
watch must first be created again.  See also the
comment about watches that have never been created in
the BUGS section.

.IP 2
Watch is in the wrong state for this operation.  This
occurs when you attempt to pause a watch that is
currently paused.

.IP 4
Watch is in an unknown state.  This occurs if M_StopWatch
does not recognize the state (running, stopped, etc.)
that the watch is in.  This error should not occur, and
indicates an internal bug in M_StopWatch.

.IP 8
Invalid clock type.  This occurs if
.I clock
is present and one of the specified clocks is not
supported by the implementation.  See
.BR "inquiry_stopwatch" "(3)"
to determine what clocks are available.

.IP 512
Failed to allocate required memory.  When
.B pause_watch
is called with an array or group of watches, temporary
memory is allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array or group of watches.
The watches are paused, but be aware that other
problems could develop as a result of the deallocate
error.

.LP

In addition to the run time diagnostics generated by
M_StopWatch, the following problems may arise:

.IP o
In Fortran 90, the character strings in an array
constructor must all have the same length.  Pad three
letter clock names with a blank on the right to make a
four character string, for example, 'cpu '.

.IP o
Watches that are paused can not be started, stopped,
reset, or paused again until they are resumed by
.B end_pause_watch.
However, they can be read and printed.

.SH EXAMPLES
type (watchtype) w1, w2(3)
.br
type (watchgroup) g1
.br
integer errcode

call pause_watch(w1)
.br
call pause_watch(w2, err=errcode)
.br
call pause_watch(g1, (/'cpu ', 'wall'/), errcode)

The first call pauses the default clocks on a single
watch.  The second call pauses the default clocks on
three watches given as an array and returns a status
code.  The third call pauses the cpu and wall clocks on
the watches in the group
.I g1,
and returns a status code.

.SH BUGS
It cannot be determined whether or not a watch variable
or watch group has been created (passed as an argument
to
.B create_watch
or
.BR "create_watchgroup" ")."
If a watch or watch group that has never been created
is passed into
.B pause_watch,
it might generate a Fortran error due to passing a
pointer with undefined association status to the
Fortran intrinsic function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
join_watchgroup(3), leave_watchgroup(3),
option_stopwatch(3), print_watch(3), read_watch(3),
reset_watch(3), start_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!-------------------------------------------------------------------
!                 PAUSE_WATCH
!-------------------------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!          ------------------
subroutine pause_watch_actual(watch,clock,err)
!          ------------------
character(len=*),parameter :: ident_pause_watch='M_stopwatch::pause_watch(3f): pauses a M_StopWatch watch'

!----------------------------------------------------
! This routine pauses the specified clocks of the specified watches.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type (watch_pointer), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err

!----------------------------------------------------

!----------------------------------------------------
! Local variables:

type (watch_actual), pointer :: the_watch
real :: diff,readcpu,readusr,readsys
integer :: i,new_read,r,m,idiff

!----------------------------------------------------

!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=0
end if

! set the flags for which clocks to pause

call which_clocks(clock,"pause_watch",err)

! loop through the watches

do i=1,ubound(watch,dim=1)

   the_watch => watch(i)%ptr
   if (.not. associated(the_watch)) then
      call err_handler_watch(ERR_CREATE,"pause_watch","", "Watch not paused.",err)
   else

! pause each flagged clock for this watch

      call system_cpu_time(readcpu,readusr,readsys)
      if (do_cpu) then
         select case (the_watch%status%cpu)
            case (STOPPED)
            case (RUNNING)
               diff = readcpu - the_watch%last_read%cpu
               the_watch%elapsed%cpu = the_watch%elapsed%cpu + diff
               the_watch%status%cpu = PAUSED
            case (PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"pause_watch",the_watch%name, "Watch's cpu clock not paused.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"pause_watch",the_watch%name, "Watch's cpu clock not paused.",err)
         end select
      end if
      if (do_user) then
         select case (the_watch%status%user)
            case (STOPPED)
            case (RUNNING)
               diff = readusr - the_watch%last_read%user
               the_watch%elapsed%user = the_watch%elapsed%user + diff
               the_watch%status%user = PAUSED
            case (PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"pause_watch",the_watch%name, "Watch's user clock not paused.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"pause_watch",the_watch%name, "Watch's user clock not paused.",err)
         end select
      end if
      if (do_sys) then
         select case (the_watch%status%sys)
            case (STOPPED)
            case (RUNNING)
               diff = readsys - the_watch%last_read%sys
               the_watch%elapsed%sys = the_watch%elapsed%sys + diff
               the_watch%status%sys = PAUSED
            case (PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"pause_watch",the_watch%name, "Watch's sys clock not paused.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"pause_watch",the_watch%name, "Watch's sys clock not paused.",err)
         end select
      end if
      if (do_wall) then
         select case (the_watch%status%wall)
            case (STOPPED)
            case (RUNNING)
               call system_clock(count=new_read,count_rate=r,count_max=m)
               if (r==0) then
                  idiff = 0
               else
                  idiff = new_read-the_watch%last_read%wall
                  if (idiff < 0) then
                     idiff = idiff + m ! clock cycled
                  end if
               end if
               the_watch%elapsed%wall = the_watch%elapsed%wall + idiff
               the_watch%status%wall = PAUSED
            case (PAUSED)
               call err_handler_watch(ERR_BAD_STATE,"pause_watch",the_watch%name, "Watch's wall clock not paused.",err)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"pause_watch",the_watch%name, "Watch's wall clock not paused.",err)
         end select
      end if
   end if
end do

end subroutine pause_watch_actual
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!----------------------------------------------------
! Alternate forms for pause_watch
!----------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine pause_watch_ga(watch,clock,err)
!          --------------
type (watchgroup), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
type (watch_list), pointer :: list_entry
integer :: erralloc, i
if (associated(watch%head)) then
   allocate(watches(watch%wgsize),stat=erralloc)
   if (erralloc > 0) then
      call err_handler_watch(ERR_ALLOC,"pause_watch","", "Watches not paused.",err)
   else
      list_entry => watch%head
      i = 0
      do
         if (.not. associated(list_entry)) then
            exit
         end if
         i=i+1
         watches(i)%ptr => list_entry%this_watch
         list_entry => list_entry%next
      end do
      call pause_watch_actual(watches,clock,err)
      deallocate(watches,stat=erralloc)
      if (erralloc > 0) then
         call err_handler_watch(ERR_DEALLOC,"pause_watch","", "Watches paused, but further problems may develop.",err)
      end if
   end if
else
   if (present(err)) then
      err = 0
   end if
end if
end subroutine pause_watch_ga
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine pause_watch_gs(watch,clock,err)
!          --------------
type (watchgroup), intent(in) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
if (present(clock)) then
   call pause_watch_ga(watch, (/clock/),err)
else
   call pause_watch_ga(watch,default_clocks,err)
end if
end subroutine pause_watch_gs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine pause_watch_aa(watch,clock,err)
!          --------------
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
integer :: erralloc,i
allocate(watches(size(watch)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"pause_watch","", "Watches not paused.",err)
else
   do i=1,size(watch)
      watches(i)%ptr => watch(i)%ptr
   end do
   call pause_watch_actual(watches,clock,err)
end if
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"pause_watch","", "Watches paused, but further problems may develop.",err)
end if
end subroutine pause_watch_aa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine pause_watch_as(watch,clock,err)
!          --------------
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
if (present(clock)) then
   call pause_watch_aa(watch, (/clock/),err)
else
   call pause_watch_aa(watch,default_clocks,err)
end if
end subroutine pause_watch_as
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine pause_watch_sa(watch,clock,err)
!          --------------
type (watchtype), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
call pause_watch_actual(watches,clock,err)
end subroutine pause_watch_sa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine pause_watch_ss(watch,clock,err)
!          --------------
type (watchtype), intent(in) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
if (present(clock)) then
   call pause_watch_actual(watches, (/clock/),err)
else
   call pause_watch_actual(watches,default_clocks,err)
end if
end subroutine pause_watch_ss
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file end_pause_watch.3m_stopwatch.txt
.TH END_PAUSE_WATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
end_pause_watch(3f) - [M_stopwatch] resumes a paused M_StopWatch watch (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "end_pause_watch" "(watch, clock, err)"

.IP
type (watchtype), intent(IN) ::  watch
.IP OR
type (watchtype), intent(IN) ::  watch(:)
.IP OR
type (watchgroup), intent(IN) ::  watch

.IP
character(len=*), optional, intent(IN) ::  clock
.IP OR
character(len=*), intent(IN) ::  clock(:)

.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Resumes the running status of the specified clocks of
the specified watches that have previously been paused
(see
.BR "pause_watch" "(3))."
Pausing is useful when you want to temporarily stop the
clocks to avoid timing a small segment of code, for
example printed output or graphics, but do not know
which watches or clocks are running.  When
.B pause_watch
is called, the information about which of the clocks
were running is maintained, so that a subsequent call
to
.B end_pause_watch
will restart only those clocks that were running.

One or more watches must be specified.  The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to resume one watch, an array of type
.I watchtype
to resume several watches, or a variable of type
.I watchgroup
(see
.BR "M_stopwatch" "(3))"
to resume the watches in a group.

The optional argument
.I clock
specifies which clocks to resume on the specified
watch(es).  If omitted, the current default clocks (see
.BR "option_stopwatch" "(3))"
are resumed.  If present,
.I clock
must be a character string containing 'cpu', 'user',
\'sys', or 'wall', or an array of such character
strings.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch(es) will not be
resumed.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1
Watch needs to be created.  This error occurs if you
attempt to resume a watch that has been destroyed.  The
watch must first be created again.  See also the
comment about watches that have never been created in
the BUGS section.

.IP 2
Watch is in the wrong state for this operation.  This
occurs when you attempt to resume a watch that is
currently running.

.IP 4
Watch is in an unknown state.  This occurs if M_StopWatch
does not recognize the state (running, stopped, etc.)
that the watch is in.  This error should not occur, and
indicates an internal bug in M_StopWatch.

.IP 8
Invalid clock type.  This occurs if
.I clock
is present and one of the specified clocks is not
supported by the implementation.  See
.BR "inquiry_stopwatch" "(3)"
to determine what clocks are available.

.IP 512
Failed to allocate required memory.  When
.B end_pause_watch
is called with an array or group of watches, temporary
memory is allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array or group of watches.
The watches are resumed, but be aware that other
problems could develop as a result of the deallocate
error.

.LP

In addition to the run time diagnostics generated by
M_StopWatch, the following problems may arise:

.IP o
In Fortran 90, the character strings in an array
constructor must all have the same length.  Pad three
letter clock names with a blank on the right to make a
four character string, for example, 'cpu '.

.SH EXAMPLES
type (watchtype) w1, w2(3)
.br
type (watchgroup) g1
.br
integer errcode

call end_pause_watch(w1)
.br
call end_pause_watch(w2, err=errcode)
.br
call end_pause_watch(g1, (/'cpu ', 'wall'/), errcode)

The first call resumes the default clocks on a single
watch.  The second call resumes the default clocks on
three watches given as an array and returns a status
code.  The third call resumes the cpu and wall clocks
on the watches in the group
.I g1,
and returns a status code.

.SH BUGS
It cannot be determined whether or not a watch variable
or watch group has been created (passed as an argument
to
.B create_watch
or
.BR "create_watchgroup" ")."
If a watch or watch group that has never been created
is passed into
.B end_pause_watch,
it might generate a Fortran error due to passing a
pointer with undefined association status to the
Fortran intrinsic function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
inquiry_stopwatch(3), join_watchgroup(3),
leave_watchgroup(3), option_stopwatch(3),
pause_watch(3), print_watch(3), read_watch(3),
reset_watch(3), start_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!-------------------------------------------------------------------
!                 END_PAUSE_WATCH
!-------------------------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!          ----------------------
subroutine end_pause_watch_actual(watch,clock,err)
!          ----------------------
character(len=*),parameter :: ident_end_pause_watch='M_stopwatch::end_pause_watch(3f): resumes a paused M_StopWatch watch'

!----------------------------------------------------
! This routine ends the pause of the specified clocks of the specified watches.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type (watch_pointer), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err

!----------------------------------------------------

!----------------------------------------------------
! Local variables:

type (watch_actual), pointer :: the_watch
real :: readcpu,readusr,readsys
integer :: i

!----------------------------------------------------

!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=0
end if

! set the flags for which clocks to end_pause

call which_clocks(clock,"end_pause_watch",err)

! loop through the watches

do i=1,ubound(watch,dim=1)

   the_watch => watch(i)%ptr
   if (.not. associated(the_watch)) then
      call err_handler_watch(ERR_CREATE,"end_pause_watch","", "Watch not end_paused.",err)
   else

! end_pause each flagged clock for this watch

      call system_cpu_time(readcpu,readusr,readsys)
      if (do_cpu) then
         select case (the_watch%status%cpu)
            case (STOPPED)
            case (RUNNING)
               call err_handler_watch(ERR_BAD_STATE,"end_pause_watch",the_watch%name, "Watch's cpu clock remains paused.",err)
            case (PAUSED)
               the_watch%last_read%cpu = readcpu
               the_watch%status%cpu = RUNNING
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"end_pause_watch",the_watch%name, "Watch's cpu clock remains paused.",err)
         end select
      end if
      if (do_user) then
         select case (the_watch%status%user)
            case (STOPPED)
            case (RUNNING)
               call err_handler_watch(ERR_BAD_STATE,"end_pause_watch",the_watch%name, "Watch's user clock remains paused.",err)
            case (PAUSED)
               the_watch%last_read%user = readusr
               the_watch%status%user = RUNNING
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"end_pause_watch",the_watch%name, "Watch's user clock remains paused.",err)
         end select
      end if
      if (do_sys) then
         select case (the_watch%status%sys)
            case (STOPPED)
            case (RUNNING)
               call err_handler_watch(ERR_BAD_STATE,"end_pause_watch",the_watch%name, "Watch's sys clock remains paused.",err)
            case (PAUSED)
               the_watch%last_read%sys = readsys
               the_watch%status%sys = RUNNING
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"end_pause_watch",the_watch%name, "Watch's sys clock remains paused.",err)
         end select
      end if
      if (do_wall) then
         select case (the_watch%status%wall)
            case (STOPPED)
            case (RUNNING)
               call err_handler_watch(ERR_BAD_STATE,"end_pause_watch",the_watch%name, "Watch's wall clock remains paused.",err)
            case (PAUSED)
               call system_clock(count=the_watch%last_read%wall)
               the_watch%status%wall = RUNNING
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"end_pause_watch",the_watch%name, "Watch's wall clock remains paused.",err)
         end select
      end if
   end if
end do

end subroutine end_pause_watch_actual
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!----------------------------------------------------
! Alternate forms for end_pause_watch
!----------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine end_pause_watch_ga(watch,clock,err)
!          ------------------
type (watchgroup), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
type (watch_list), pointer :: list_entry
integer :: erralloc, i
if (associated(watch%head)) then
   allocate(watches(watch%wgsize),stat=erralloc)
   if (erralloc > 0) then
      call err_handler_watch(ERR_ALLOC,"end_pause_watch","", "Watches remain paused.",err)
   else
      list_entry => watch%head
      i = 0
      do
         if (.not. associated(list_entry)) then
            exit
         end if
         i=i+1
         watches(i)%ptr => list_entry%this_watch
         list_entry => list_entry%next
      end do
      call end_pause_watch_actual(watches,clock,err)
      deallocate(watches,stat=erralloc)
      if (erralloc > 0) then
         call err_handler_watch(ERR_DEALLOC,"end_pause_watch","", "Watches resumed, but further problems may develop.",err)
      end if
   end if
else
   if (present(err)) then
      err = 0
   end if
end if
end subroutine end_pause_watch_ga
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine end_pause_watch_gs(watch,clock,err)
!          ------------------
type (watchgroup), intent(in) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
if (present(clock)) then
   call end_pause_watch_ga(watch, (/clock/),err)
else
   call end_pause_watch_ga(watch,default_clocks,err)
end if
end subroutine end_pause_watch_gs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

subroutine end_pause_watch_aa(watch,clock,err)
!          ------------------
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
integer :: erralloc,i
allocate(watches(size(watch)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"end_pause_watch","", "Watches remain paused.",err)
else
   do i=1,size(watch)
      watches(i)%ptr => watch(i)%ptr
   end do
   call end_pause_watch_actual(watches,clock,err)
end if
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"end_pause_watch","", "Watches resumed, but further problems may develop.",err)
end if
end subroutine end_pause_watch_aa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

subroutine end_pause_watch_as(watch,clock,err)
!          ------------------
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
if (present(clock)) then
   call end_pause_watch_aa(watch, (/clock/),err)
else
   call end_pause_watch_aa(watch,default_clocks,err)
end if
end subroutine end_pause_watch_as
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

subroutine end_pause_watch_sa(watch,clock,err)
!          ------------------
type (watchtype), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
call end_pause_watch_actual(watches,clock,err)
end subroutine end_pause_watch_sa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

subroutine end_pause_watch_ss(watch,clock,err)
!          ------------------
type (watchtype), intent(in) :: watch
character(len=*), optional, intent(in) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
if (present(clock)) then
   call end_pause_watch_actual(watches, (/clock/),err)
else
   call end_pause_watch_actual(watches,default_clocks,err)
end if
end subroutine end_pause_watch_ss
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file read_watch.3m_stopwatch.txt
.TH READ_WATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
read_watch(3f) - [M_stopwatch] reads the values from a M_StopWatch watch (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "read_watch" "(read_result, watch, clock, err)"

.IP
real, intent(OUT) ::  read_result
.IP OR
real, pointer ::  read_result(:)
.IP OR
real, pointer ::  read_result(:,:)

.IP
type (watchtype), intent(IN) ::  watch
.IP OR
type (watchtype), intent(IN) ::  watch(:)

.IP
character(len=*), optional, intent(IN) ::  clock
.IP OR
character(len=*), intent(IN) ::  clock(:)

.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Returns the value of the specified clocks from the
specified watches in
.I read_result
.
One or more watches must be specified.  The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to read one watch, or an array of type
.I watchtype
to read several watches.
.I watch
can not be a
.I watchgroup
because there is no natural order of the watches in the
group to use in constructing an array for the result.

The optional argument
.I clock
specifies which clocks to read from the specified
watch(es).  If omitted, the current default clocks (see
.BR "option_stopwatch" "(3))"
are read.  If present,
.I clock
must be a character string containing 'cpu', 'user',
\'sys', or 'wall', or an array of such character
strings.

The type of
.I read_result
must agree with the form of the arguments
.I watch
and
.I clock:

If
.I watch
is a scalar and
.I clock
is a scalar, then
.I read_result
must be a real scalar.

If
.I watch
is an array and
.I clock
is a scalar, then
.I read_result
must be a pointer to a rank 1 real array.  The ith
entry of the result is the specified clock value on
.I watch(i).

If
.I watch
is a scalar and
.I clock
is either an array or omitted, then
.I read_result
must be a pointer to a rank 1 real array.  The ith
entry of the result is the value in
.I clock(i)
on the specified
.I watch.
In the case that
.I clock
is omitted, note that the default clocks specify the
contents of the result, and the default clocks can be
determined using
.BR "inquiry_stopwatch" "(3)."

If
.I watch
is an array and
.I clock
is either an array or omitted, then
.I read_result
must be a pointer to a rank 2 real array.  The (i,j)th
entry of the result is the value in
.I clock(j)
on
.I watch(i).

If
.I read_result
is a pointer to an array, it will be allocated by
.B read_watch
, and should be deallocated after use to avoid memory
leakage.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch(es) will not be read.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1
Watch needs to be created.  This error occurs if you
attempt to read a watch that has been destroyed.  The
watch must first be created again.  See also the
comment about watches that have never been created in
the BUGS section.

.IP 4
Watch is in an unknown state.  This occurs if M_StopWatch
does not recognize the state (running, stopped, etc.)
that the watch is in.  This error should not occur, and
indicates an internal bug in M_StopWatch.

.IP 8
Invalid clock type.  This occurs if
.I clock
is present and one of the specified clocks is not
supported by the implementation.  See
.BR "inquiry_stopwatch" "(3)"
to determine what clocks are available.

.IP 512
Failed to allocate required memory.  When
.B read_watch
is called with an array or group of watches, temporary
memory is allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array or group of watches.
The watches are read, but be aware that other problems
could develop as a result of the deallocate error.

.LP

In addition to the run time diagnostics generated by
M_StopWatch, the following problems may arise:

.IP o
In Fortran 90, the character strings in an array
constructor must all have the same length.  Pad three
letter clock names with a blank on the right to make a
four character string, for example, 'cpu '.

.SH EXAMPLES
type (watchtype) w1, w2(3)
.br
real x
.br
real, pointer ::  y(:), z(:,:)
.br
integer errcode

call read_watch(x, w1, 'user')
.br
call read_watch(y, w1, err=errcode)
.br
call read_watch(z, w2, (/'cpu ', 'wall'/), errcode)
.br
deallocate(y, z)

The first call reads the user clock on a single watch.
The second call reads the default clocks on a single
watch and returns a status code.  y is allocated with
dimension equal to the number of default clocks.  The
third call reads the cpu and wall clocks from three
watches given as an array and returns a status code.
The deallocate statement frees the memory allocated in
.I read_watch
.

.SH BUGS
It cannot be determined whether or not a watch variable
or watch group has been created (passed as an argument
to
.B create_watch
or
.BR "create_watchgroup" ")."
If a watch or watch group that has never been created
is passed into
.B read_watch,
it might generate a Fortran error due to passing a
pointer with undefined association status to the
Fortran intrinsic function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
join_watchgroup(3), leave_watchgroup(3),
option_stopwatch(3), pause_watch(3), print_watch(3),
reset_watch(3), start_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!-------------------------------------------------------------------
!                 READ_WATCH
!-------------------------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!          -----------------
subroutine read_watch_actual(read_result,watch,clock,err)
!          -----------------
character(len=*),parameter :: ident_read_watch='M_stopwatch::read_watch(3f): reads the values from a M_StopWatch watch'

!----------------------------------------------------
! This routine reads the specified clocks from the specified watches.
! Returns 0.0 on error conditions.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

real, pointer, dimension(:,:) :: read_result
type (watch_pointer), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err

!----------------------------------------------------

!----------------------------------------------------
! Local variables:

type (watch_actual), pointer :: the_watch
integer :: new_read,r,m,idiff,i,j,erralloc,clock_rate
real :: readcpu,readusr,readsys
real, target, save, dimension(1,1) :: zero_result

!----------------------------------------------------

!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=0
end if

! initialize the result to 0.0

allocate(read_result(size(watch),size(clock)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"read_watch","", "Fatal error may follow.",err)
   read_result => zero_result
end if
read_result = 0.0

! set the flags for which clocks to read

call which_clocks(clock,"read_watch",err)
call system_clock(count_rate=clock_rate)

! loop through the watches

do i=1,ubound(watch,dim=1)

   the_watch => watch(i)%ptr
   if (.not. associated(the_watch)) then
      call err_handler_watch(ERR_CREATE,"read_watch","", "Returning 0.0 for all clocks on this watch.",err)
   else

! read each flagged clock for this watch

      j=0
      call system_cpu_time(readcpu,readusr,readsys)
      if (do_cpu) then
         j=j+1
         select case (the_watch%status%cpu)
            case (STOPPED, PAUSED)
               read_result(i,j) = the_watch%elapsed%cpu
            case (RUNNING)
               read_result(i,j) = the_watch%elapsed%cpu + readcpu - the_watch%last_read%cpu
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"read_watch",the_watch%name, "Returning 0.0 for value of cpu clock.",err)
         end select
      end if
      if (do_user) then
         j=j+1
         select case (the_watch%status%user)
            case (STOPPED, PAUSED)
               read_result(i,j) = the_watch%elapsed%user
            case (RUNNING)
               read_result(i,j) = the_watch%elapsed%user + readusr - the_watch%last_read%user
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"read_watch",the_watch%name, "Returning 0.0 for value of user clock.",err)
         end select
      end if
      if (do_sys) then
         j=j+1
         select case (the_watch%status%sys)
            case (STOPPED, PAUSED)
               read_result(i,j) = the_watch%elapsed%sys
            case (RUNNING)
               read_result(i,j) = the_watch%elapsed%sys + readsys - the_watch%last_read%sys
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"read_watch",the_watch%name, "Returning 0.0 for value of sys clock.",err)
         end select
      end if
      if (do_wall) then
         j=j+1
         select case (the_watch%status%wall)
            case (STOPPED, PAUSED)
               read_result(i,j) = real(the_watch%elapsed%wall)/real(clock_rate)
            case (RUNNING)
               call system_clock(count=new_read,count_rate=r,count_max=m)
               if (r==0) then
                  idiff = 0
               else
                  idiff = new_read-the_watch%last_read%wall
                  if (idiff < 0) then
                     idiff = idiff + m ! clock cycled
                  end if
               end if
               read_result(i,j) = real(the_watch%elapsed%wall+idiff)/real(clock_rate)
            case (OMITTED)
            case default
               call err_handler_watch(ERR_UNK_STATE,"read_watch",the_watch%name,&
                    "Returning 0.0 for value of wall clock.",err)
         end select
      end if
   end if
end do

end subroutine read_watch_actual
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!----------------------------------------------------
! Alternate forms for read_watch
!----------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine read_watch_aa(read_result,watch,clock,err)
!          -------------
real, pointer, dimension(:,:) :: read_result
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
real, target, dimension(1,1) :: zero_result
integer :: idiff,isize,erralloc,i
idiff = lbound(watch,dim=1)-1
isize = ubound(watch,dim=1)-lbound(watch,dim=1)+1
allocate(watches(isize),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"read_watch","", &
        "Returning 0.0 for watch values.",err)
   read_result => zero_result
   read_result = 0.0
else
   do i=1,isize
      watches(i)%ptr => watch(i+idiff)%ptr
   end do
   call read_watch_actual(read_result,watches,clock,err)
end if
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"read_watch","", &
       "Watches read, but further problems may develop.",err)
end if
end subroutine read_watch_aa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine read_watch_ax(read_result,watch,err)
!          -------------
real, pointer, dimension(:,:) :: read_result
type (watchtype), intent(in), dimension(:) :: watch
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
real, target, dimension(1,1) :: zero_result
real, pointer, dimension(:,:) :: double_pointer
integer :: erralloc,i
allocate(watches(size(watch)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"read_watch","", &
        "Returning 0.0 for watch values.",err)
   read_result => zero_result
   read_result = 0.0
else
   do i=1,size(watch)
      watches(i)%ptr => watch(i)%ptr
   end do
   call read_watch_actual(double_pointer,watches,default_clocks,err)
   read_result => double_pointer
end if
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"read_watch","", &
       "Watches read, but further problems may develop.",err)
end if
end subroutine read_watch_ax
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine read_watch_as(read_result,watch,clock,err)
!        -------------
real, pointer, dimension(:) :: read_result
type (watchtype), intent(in), dimension(:) :: watch
character(len=*), intent(in) :: clock
integer, optional, intent(out) :: err
integer :: idiff,isize,erralloc,i
type (watch_pointer), allocatable, dimension(:) :: watches
real, pointer, dimension(:,:) :: double_pointer
real, target, save, dimension(1,1) :: zero_result
idiff = lbound(watch,dim=1)-1
isize = ubound(watch,dim=1)-lbound(watch,dim=1)+1
allocate(watches(isize),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"read_watch","", "Returning 0.0 for watch values.",err)
   read_result => zero_result(:,1)
   read_result = 0.0
else
   do i=1,isize
      watches(i)%ptr => watch(i+idiff)%ptr
   end do
   call read_watch_actual(double_pointer,watches, (/clock/) ,err)
   read_result => double_pointer(:,1)
end if
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"read_watch","", "Watches read, but further problems may develop.",err)
end if
end subroutine read_watch_as
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! read_watch_sa was split into two routine (the other being _sx) with and
! without clock instead of having clock be optional because when this was
! a function the dimension of the result was size(clock) or size(default_clocks)
! depending on the presence of clock, so the split was necessary to use
! real, dimension(size(clock)) :: read_watch_sa
! It was not changed back to a single routine because I realized it could be
! after I sent the code out to beta testers.

subroutine read_watch_sa(read_result,watch,clock,err)
!          -------------
real, pointer, dimension(:) :: read_result
type (watchtype), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
real, pointer, dimension(:,:) :: double_pointer
watches(1)%ptr => watch%ptr
call read_watch_actual(double_pointer,watches,clock,err)
read_result => double_pointer(1,:)
end subroutine read_watch_sa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine read_watch_sx(read_result,watch,err)
!          -------------
real, pointer, dimension(:) :: read_result
type (watchtype), intent(in) :: watch
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
real, pointer, dimension(:,:) :: double_pointer
watches(1)%ptr => watch%ptr
call read_watch_actual(double_pointer,watches,default_clocks,err)
read_result => double_pointer(1,:)
end subroutine read_watch_sx
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine read_watch_ss(read_result,watch,clock,err)
!          -------------
real, intent(out) :: read_result
type (watchtype), intent(in) :: watch
character(len=*), intent(in) :: clock
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
real, pointer, dimension(:,:) :: double_pointer
watches(1)%ptr => watch%ptr
call read_watch_actual(double_pointer, watches, (/clock/),err)
read_result = double_pointer(1,1)
end subroutine read_watch_ss
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file print_watch.3m_stopwatch.txt
.TH PRINT_WATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
print_watch(3f) - [M_stopwatch] prints the current value of a M_StopWatch
watch (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "print_watch" "(watch, clock, title, form, err)"

.IP
type (watchtype), intent(IN) ::  watch
.IP OR
type (watchtype), intent(IN) ::  watch(:)
.IP OR
type (watchgroup), intent(IN) ::  watch

.IP
character(len=*), optional, intent(IN) ::  clock
.IP OR
character(len=*), intent(IN) ::  clock(:)

.IP
character(len=*), optional, intent(IN) ::  title, form

.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Prints the specified clocks of the specified watches.
A title line is printed followed by two lines for each
watch, the first containing the name of the watch and
the second containing the values of the specified
clocks.  Output is written to a user specified I/O unit
(see
.BR "option_stopwatch" "(3))"
which is 6 by default.

One or more watches must be specified.  The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to print one watch, an array of type
.I watchtype
to print several watches, or a variable of type
.I watchgroup
(see
.BR "M_stopwatch" "(3))"
to print the watches in a group.

The optional argument
.I clock
specifies which clocks to print from the specified
watch(es).  If omitted, the current default clocks (see
.BR "option_stopwatch" "(3))"
are printed.  If present,
.I clock
must be a character string containing 'cpu', 'user',
\'sys', or 'wall', or an array of such character
strings.

The optional argument
.I title
is a character string to be printed before printing the
watch values.  If omitted, the string ``Times printed
by M_StopWatch:''  is printed.

The optional argument
.I form
determines the form for printing time.  The valid
values are:    .IP 'sec',
seconds
.IP 'hh:mm:ss',
colon separated hours, minutes and seconds
.IP '[[hh:]mm:]ss',
same as 'hh:mm:ss' except hours and minutes are printed
only if nonzero
If omitted, the current default form is used.  The
default form is initially 'sec' and can be reset by
.BR "option_stopwatch" "(3)"
.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch(es) will not be
printed.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1
Watch needs to be created.  This error occurs if you
attempt to print a watch that has been destroyed.  The
watch must first be created again.  See also the
comment about watches that have never been created in
the BUGS section.

.IP 4
Watch is in an unknown state.  This occurs if M_StopWatch
does not recognize the state (running, stopped, etc.)
that the watch is in.  This error should not occur, and
indicates an internal bug in M_StopWatch.

.IP 8
Invalid clock type.  This occurs if
.I clock
is present and one of the specified clocks is not
supported by the implementation.  See
.BR "inquiry_stopwatch" "(3)"
to determine what clocks are available.

.IP 256
I/O unit is not open for writing.  The I/O unit to
which
.B print_watch
expects to write is not open for writing.  The I/O unit
number is set by
.I io_unit_print
in
.B option_stopwatch
and is 6 by default.

.IP 512
Failed to allocate required memory.  When
.B print_watch
is called with an array or group of watches, temporary
memory is allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array or group of watches.
The watches are printed, but be aware that other
problems could develop as a result of the deallocate
error.

.IP 2048
Illegal output form.  This error occurs if
.I form
is not one of the strings listed above.

.LP

In addition to the run time diagnostics generated by
M_StopWatch, the following problems may arise:

.IP o
In Fortran 90, the character strings in an array
constructor must all have the same length.  Pad three
letter clock names with a blank on the right to make a
four character string, for example, 'cpu '.

.SH EXAMPLES
type (watchtype) w1, w2(3)
.br
type (watchgroup) g1
.br
integer errcode

call print_watch(w1)
.br
call print_watch(w2, title='Array of 3 watches',
err=errcode)
.br
call print_watch(g1, (/'cpu ', 'wall'/), errcode)

The first call prints the default clocks from a single
watch, and the default title.  The second call prints
the default clocks on three watches given as an array
and the title ``Array of 3 watches'', and returns a
status code.  The third call prints the cpu and wall
clocks on the watches in the group
.I g1,
and returns a status code.

.SH BUGS
It cannot be determined whether or not a watch variable
or watch group has been created (passed as an argument
to
.B create_watch
or
.BR "create_watchgroup" ")."
If a watch or watch group that has never been created
is passed into
.B print_watch,
it might generate a Fortran error due to passing a
pointer with undefined association status to the
Fortran intrinsic function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
join_watchgroup(3), leave_watchgroup(3),
option_stopwatch(3), pause_watch(3), read_watch(3),
reset_watch(3), start_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!-------------------------------------------------------------------
!                 PRINT_WATCH
!-------------------------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!          ------------------
subroutine print_watch_actual(watch,clock,title,form,err)
!          ------------------
character(len=*),parameter :: ident_print_watch='M_stopwatch::print_watch(3f): prints the current value of a M_StopWatch'

!----------------------------------------------------
! This routine prints the specified clocks of the specified watches.
! A title for the output may be provided, or a default title will be
! printed if title is not present.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

type (watch_pointer), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
character(len=*), optional, intent(in) :: title, form
integer, optional, intent(out) :: err

!----------------------------------------------------

!----------------------------------------------------
! Local variables:

type (watch_actual), pointer :: the_watch
type (watchtype) :: toread
integer :: i, badunit, myerr
character(len=4) :: intfile
character(len=FORM_LEN) :: loc_form
real :: readval

!----------------------------------------------------

!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=0
end if
myerr=0

! determine the form for printed times

if (present(form)) then
   if (form=="sec" .or. form=="hh:mm:ss" .or. form=="[[hh:]mm:]ss") then
      loc_form = form
   else
      call err_handler_watch(ERR_FORM,"print_watch",form,"Using form 'sec'",myerr)
      loc_form = "sec"
   end if
else
   loc_form = default_form
end if

! print the title

if (present(title)) then
   if (len(title) /= 0) then
      write(unit=iounit,fmt="(a)",iostat=badunit) title
   else
      badunit = 0
   end if
else
   write(unit=iounit,fmt="("" Times printed by M_StopWatch:"")",iostat=badunit)
end if

if (badunit > 0) then
   write(unit=intfile,fmt="(i4)") iounit
   call err_handler_watch(ERR_IO,"print_watch",intfile, "Watch values not printed.",myerr)
   return
end if

! set the flags for which clocks to read

call which_clocks(clock,"print_watch",err)

! loop through the watches

do i=1,ubound(watch,dim=1)

   the_watch => watch(i)%ptr
   if (.not. associated(the_watch)) then
      call err_handler_watch(ERR_CREATE,"print_watch","", "Watch not printed.",myerr)
   else
      toread%ptr => watch(i)%ptr

      if (len_trim(the_watch%name) /= 0) then
         write(unit=iounit,fmt="(a2,a,a1)") "  ",trim(the_watch%name),":"
      end if
      write(unit=iounit,fmt="(a6)",advance="no") "      "
      if (do_cpu .and. the_watch%status%cpu /= OMITTED) then
!         write(unit=iounit,fmt="(a6)",advance="no") " cpu="
         call read_watch(readval,toread,"cpu",err)
         call print_time("  cpu=",readval,loc_form)
         call which_clocks(clock,"print_watch",err)
      end if
      if (do_user .and. the_watch%status%user /= OMITTED) then
!         write(unit=iounit,fmt="(a6)",advance="no") " user="
         call read_watch(readval,toread,"user",err)
         call print_time(" user=",readval,loc_form)
         call which_clocks(clock,"print_watch",err)
      end if
      if (do_sys .and. the_watch%status%sys /= OMITTED) then
!         write(unit=iounit,fmt="(a6)",advance="no") " sys="
         call read_watch(readval,toread,"sys",err)
         call print_time("  sys=",readval,loc_form)
         call which_clocks(clock,"print_watch",err)
      end if
      if (do_wall .and. the_watch%status%wall /= OMITTED) then
!         write(unit=iounit,fmt="(a6)",advance="no") " wall="
         call read_watch(readval,toread,"wall",err)
         call print_time(" wall=",readval,loc_form)
         call which_clocks(clock,"print_watch",err)
      end if
      write(unit=iounit,fmt=*)

   end if
end do

if (present(err)) then
   err=ior(err,myerr)
end if

end subroutine print_watch_actual
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine print_time(str,time,form)
!          ----------

! prints the time under the specified format

character(len=*), intent(in) :: str
real, intent(in) :: time
character(len=*), intent(in) :: form

integer :: h,m,si
real :: sf

if (form=="sec") then
   write(unit=iounit,fmt="(a6,f8.2)",advance="no") str,time
else if (form=="hh:mm:ss") then
   h = time/3600.0
   m = (time-h*3600.0)/60.0
   si = time-h*3600.0-m*60.0
   sf = time-int(time)
   write(unit=iounit,fmt="(a6,i4,"":"",i2.2,"":"",i2.2,f3.2)",advance="no") str,h,m,si,sf
else if (form=="[[hh:]mm:]ss") then
   h = time/3600.0
   m = (time-h*3600.0)/60.0
   si = time-h*3600.0-m*60.0
   sf = time-int(time)
   if (h>0) then
      write(unit=iounit,fmt="(a6,i4,"":"",i2.2,"":"",i2.2,f3.2)",advance="no") str,h,m,si,sf
   else if (m>0) then
      write(unit=iounit,fmt="(a6,a5,i2,"":"",i2.2,f3.2)",advance="no") str,"     ",m,si,sf
   else
      write(unit=iounit,fmt="(a6,f13.2)",advance="no") str,time
   end if
end if

end subroutine print_time
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
! Alternate forms for print_watch
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine print_watch_ga(watch,clock,title,form,err)

type (watchgroup), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
character(len=*), optional, intent(in) :: title, form
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
type (watch_list), pointer :: list_entry
integer :: erralloc, i

if (associated(watch%head)) then
   allocate(watches(watch%wgsize),stat=erralloc)
   if (erralloc > 0) then
      call err_handler_watch(ERR_ALLOC,"print_watch","", "Watch values not printed.",err)
   else
      list_entry => watch%head
      i = 0
      do
         if (.not. associated(list_entry)) then
            exit
         end if
         i=i+1
         watches(i)%ptr => list_entry%this_watch
         list_entry => list_entry%next
      end do
      call print_watch_actual(watches,clock,title,form,err)
      deallocate(watches,stat=erralloc)
      if (erralloc > 0) then
         call err_handler_watch(ERR_DEALLOC,"print_watch","", "Watches printed, but further problems may develop.",err)
      end if
   end if
else
   if (present(err)) then
      err = 0
   end if
end if

end subroutine print_watch_ga
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine print_watch_gs(watch,clock,title,form,err)

type (watchgroup), intent(in) :: watch
character(len=*), optional, intent(in) :: clock
character(len=*), optional, intent(in) :: title, form
integer, optional, intent(out) :: err

if (present(clock)) then
   call print_watch_ga(watch, (/clock/),title,form,err)
else
   call print_watch_ga(watch,default_clocks,title,form,err)
end if

end subroutine print_watch_gs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine print_watch_aa(watch,clock,title,form,err)

type (watchtype), intent(in), dimension(:) :: watch
character(len=*), intent(in), dimension(:) :: clock
character(len=*), optional, intent(in) :: title, form
integer, optional, intent(out) :: err

   type (watch_pointer), allocatable, dimension(:) :: watches
   integer :: erralloc,i

   allocate(watches(size(watch)),stat=erralloc)
   if (erralloc > 0) then
      call err_handler_watch(ERR_ALLOC,"print_watch","", "Watch values not printed.",err)
   else
      do i=1,size(watch)
         watches(i)%ptr => watch(i)%ptr
      end do
      call print_watch_actual(watches,clock,title,form,err)
   end if

   deallocate(watches,stat=erralloc)
   if (erralloc > 0) then
      call err_handler_watch(ERR_DEALLOC,"print_watch","", "Watches printed, but further problems may develop.",err)
   end if

end subroutine print_watch_aa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine print_watch_as(watch,clock,title,form,err)

type (watchtype), intent(in), dimension(:) :: watch
character(len=*), optional, intent(in) :: clock
character(len=*), optional, intent(in) :: title, form
integer, optional, intent(out) :: err

   if (present(clock)) then
      call print_watch_aa(watch, [clock],title,form,err)
   else
      call print_watch_aa(watch,default_clocks,title,form,err)
   end if

end subroutine print_watch_as
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine print_watch_sa(watch,clock,title,form,err)

type (watchtype), intent(in) :: watch
character(len=*), intent(in), dimension(:) :: clock
character(len=*), optional, intent(in) :: title, form
integer, optional, intent(out) :: err

   type (watch_pointer), dimension(1) :: watches

   watches(1)%ptr => watch%ptr
   call print_watch_actual(watches,clock,title,form,err)

end subroutine print_watch_sa
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine print_watch_ss(watch,clock,title,form,err)
!
type (watchtype), intent(in) :: watch
character(len=*), optional, intent(in) :: clock
character(len=*), optional, intent(in) :: title, form
integer, optional, intent(out) :: err

   type (watch_pointer), dimension(1) :: watches

   watches(1)%ptr => watch%ptr
   if (present(clock)) then
      call print_watch_actual(watches, (/clock/),title,form,err)
   else
      call print_watch_actual(watches,default_clocks,title,form,err)
   end if

end subroutine print_watch_ss
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file option_stopwatch.3m_stopwatch.txt
.TH OPTION_STOPWATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
option_stopwatch(3f) - [M_stopwatch] sets M_StopWatch options (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "option_stopwatch" "(default_clock, io_unit_print, io_unit_error, print_errors, abort_errors, print_form, err)"

.IP
character(len=*), optional, intent(IN) ::
default_clock(:)
.IP OR
character(len=*), optional, intent(IN) ::  default_clock

.IP
integer, optional, intent(IN) ::  io_unit_print,
io_unit_err
.IP
logical, optional, intent(IN) ::  print_errors,
abort_errors
.IP
character(len=*), optional, intent(IN) ::  print_form
.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Sets options that control the behavior of M_StopWatch.
All arguments are optional and have intent IN (except
the status code
.I err
which has intent OUT). These options are global in
nature, and remain in effect until another call to
.B option_stopwatch
changes them.
The argument
.I default_clock
determines what clocks will be used for all subsequent
operations in which the
.I clock
argument is omitted.  This allows you to specify what
clocks you are interested in once and for all, and not
have to specify those clocks with every subroutine
call.  The initial default value is (/'cpu ', 'user',
\'sys ', 'wall'/), i.e., all clocks.  However, if any
clocks are not available in the implementation, they
will be automatically removed from the list of default
clocks.

Printed output can be redirected to any valid I/O unit
number.
.I io_unit_print
determines the unit for output from subroutine
.BI "print_watch." " io_unit_error"
determines the unit for any error messages printed by
M_StopWatch.  When an I/O unit is reset by one of these
variables, the unit must already be open for writing.
The initial default is 6 for both I/O units, which is
standard output on many systems.

What to do when an error occurs is controlled by the
two logical variables
.I print_errors
and
.I abort_errors.
If
.I print_errors
is TRUE, then an error message will be printed to
.I io_unit_error
whenever an error condition occurs.  In all cases where
an error can be detected, the program can continue to
execute, although the behavior of M_StopWatch might not
be as expected.  If
.I abort_errors
is TRUE, then the program will terminate when an error
condition occurs.  The initial defaults are TRUE for
.I print_errors
and FALSE for
.I abort_errors.

The argument
.I print_form
determines the form for printing time when
.I form
is omitted in
.I print_errors
.  The valid values are:    .IP 'sec',
seconds
.IP 'hh:mm:ss',
colon separated hours, minutes and seconds
.IP '[[hh:]mm:]ss',
same as 'hh:mm:ss' except hours and minutes are printed
only if nonzero
The default value is 'sec'.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 8
Invalid clock type.  This occurs if
.I default_clock
is present and one of the specified clocks is not
supported by the implementation.  See
.BR "inquiry_stopwatch" "(3)"
to determine what clocks are available.

.IP 16
Too many clocks specified.  This occurs when the
argument
.I default_clock
is an array longer than four.

.IP 256
I/O unit is not open for writing.  The I/O unit
requested for
.I io_unit_print
or
.I io_unit_error
is not open for writing.

.IP 512
Failed to allocate required memory.  This error occurs
if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
memory.  Be aware that other problems could develop as
a result of the deallocate error.

.IP 2048
Illegal output form.  This error occurs if
.I print_form
is not one of the strings listed above.

.LP

In addition to the run time diagnostics generated by
M_StopWatch, the following problems may arise:

.IP o
In Fortran 90, the character strings in an array
constructor must all have the same length.  Pad three
letter clock names with a blank on the right to make a
four character string, for example, 'cpu '.

.SH EXAMPLES
call option_stopwatch(default_clock='cpu',
abort_error=.true.)
.br
call option_stopwatch(io_unit_print=11, io_unit_error=12)

The first call sets the default clock to be the cpu
clock and says to terminate the program if an error
occurs.  The second call reassigns the I/O units.

.SH BUGS
None known.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
join_watchgroup(3), leave_watchgroup(3), pause_watch(3),
print_watch(3), read_watch(3), reset_watch(3),
start_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!-------------------------------------------------------------------
!                 OPTION_STOPWATCH
!-------------------------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!          ------------------
subroutine option_stopwatch_a(default_clock,io_unit_print,io_unit_error, print_errors,abort_errors,print_form,err)
!          ------------------
character(len=*),parameter :: ident_option_stopwatch='M_stopwatch::option_stopwatch(3f): sets M_StopWatch options'

!----------------------------------------------------
! This routine allows the user to set certain options.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

! DEC bug 1.  Can't have optional array argument here.
!character(len=*), optional, intent(in), dimension(:) :: default_clock
character(len=*), intent(in), dimension(:) :: default_clock
integer, optional, intent(in) :: io_unit_print, io_unit_error
logical, optional, intent(in) :: print_errors, abort_errors
character(len=*), optional, intent(in) :: print_form
integer, optional, intent(out) :: err

!----------------------------------------------------

!----------------------------------------------------
! Local variables:

logical :: isopen
character(len=8) :: iswrite
character(len=4) :: intfile
character(len=CLOCK_LEN), dimension(4) :: def_clocks
integer :: i,j,erralloc,r
real :: cpu,user,sys

!----------------------------------------------------

!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=0
end if

! default_clocks

! DEC bug 1. default_clock must be present
!if (present(default_clock)) then ! note dummy argument is default_clock and
                                 ! module variable is default_clocks (with an s)
   call system_cpu_time(cpu,user,sys)
   call system_clock(count_rate=r)
   j=0
   do i=1,size(default_clock)
      if (default_clock(i)=="none") then
         ! do nothing, this is for the DEC bug 1
      else if (default_clock(i)/="cpu" .and. default_clock(i)/="user" .and. &
         default_clock(i)/="sys" .and. default_clock(i)/="wall") then
         ! not a legal clock name
         call err_handler_watch(ERR_CLOCK,"option_stopwatch",default_clock(i), &
              "That clock not included in the default clocks.",err)
      else if ((user<0.0 .and. default_clock(i)=="user") .or. &
              (sys<0.0 .and. default_clock(i)=="sys") .or. &
              (cpu<0.0 .and. default_clock(i)=="cpu") .or. &
              (r==0 .and. default_clock(i)=="wall")) then
         ! clock not available on this system
         call err_handler_watch(ERR_CLOCK,"option_stopwatch",default_clock(i), &
              "That clock not included in the default clocks.",err)
      else
         j=j+1
         if (j<=4) then
            def_clocks(j)=default_clock(i)
         else
            j=4
            call err_handler_watch(ERR_TMC,"option_stopwatch",default_clock(i), &
              "That clock not included in the default clocks.",err)
         end if
      end if
   end do
   if (j>0) then
      if (allocated(default_clocks)) then
         deallocate(default_clocks,stat=erralloc)
         if (erralloc > 0) then
            call err_handler_watch(ERR_DEALLOC,"option_stopwatch","", "Further problems may develop.",err)
         end if
      end if
      allocate(default_clocks(j),stat=erralloc)
      if (erralloc > 0) then
         call err_handler_watch(ERR_ALLOC,"option_stopwatch","", "There are no default clocks.",err)
      else
         default_clocks = def_clocks(1:j)
      end if
   end if
! DEC bug 1.  Got rid of this if statement
!end if

! error messages unit number

if (present(io_unit_error)) then
   inquire(unit=io_unit_error,opened=isopen,write=iswrite)
   if(.not. isopen .or. iswrite /= "YES") then
      write(unit=intfile,fmt="(i4)") io_unit_error
      call err_handler_watch(ERR_IO,"option_stopwatch",intfile, "I/O unit number for errors not reset as requested.",err)
   else
      errunit = io_unit_error
   end if
end if

! printed output unit number

if (present(io_unit_print)) then
   inquire(unit=io_unit_print,opened=isopen,write=iswrite)
   if(.not. isopen .or. iswrite /= "YES") then
      write(unit=intfile,fmt="(i4)") io_unit_print
      call err_handler_watch(ERR_IO,"option_stopwatch",intfile, "I/O unit number for printing not reset as requested.",err)
   else
      iounit = io_unit_print
   end if
end if

! behavior on errors

if (present(print_errors)) then
   errprint = print_errors
end if
if (present(abort_errors)) then
   errabort = abort_errors
end if

! form for printing time

if (present(print_form)) then
   if (print_form=="sec" .or. print_form=="hh:mm:ss" .or.  print_form=="[[hh:]mm:]ss") then
      default_form = print_form
   else
      call err_handler_watch(ERR_FORM,"option_stopwatch",print_form, "Default not changed.",err)
   end if
end if

end subroutine option_stopwatch_a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!----------------------------------------------------
! Alternate forms for option_stopwatch
!----------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine option_stopwatch_s(default_clock,io_unit_print,io_unit_error, print_errors,abort_errors,print_form,err)
! DEC bug 1.  Make default_clock optional here instead of as an array
!character(len=*), intent(in) :: default_clock
character(len=*), optional, intent(in) :: default_clock
integer, optional, intent(in) :: io_unit_print, io_unit_error
logical, optional, intent(in) :: print_errors, abort_errors
character(len=*), optional, intent(in) :: print_form
integer, optional, intent(out) :: err
! DEC bug 1.  Should only have the first case here.
if (present(default_clock)) then
   call option_stopwatch_a((/default_clock/),io_unit_print,io_unit_error, print_errors,abort_errors,print_form,err)
else
   call option_stopwatch_a((/"none"/),io_unit_print,io_unit_error, print_errors,abort_errors,print_form,err)
end if
end subroutine option_stopwatch_s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file inquiry_stopwatch.3m_stopwatch.txt
.TH INQUIRY_STOPWATCH 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
inquiry_stopwatch(3f) - [M_stopwatch] returns M_StopWatch options and system
dependent values (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "inquiry_stopwatch" "(default_clock, io_unit_print, io_unit_error, print_errors, abort_errors, print_form, cpu_avail, user_avail, sys_avail, wall_avail, cpu_prec, wall_prec, version, err)"

.IP
character(len=*), optional, intent(OUT) ::
default_clock(4)
.IP
integer, optional, intent(OUT) ::  io_unit_print,
io_unit_err
.IP
logical, optional, intent(OUT) ::  print_errors,
abort_errors
.IP
character(len=*), optional, intent(OUT) ::  print_form
.IP
logical, optional, intent(OUT) ::  cpu_avail,
user_avail, sys_avail, wall_avail
.IP
real, optional, intent(OUT) ::  cpu_prec, wall_prec
.IP
character(len=16), optional, intent(OUT) ::  version
.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Returns the value of M_StopWatch options and other system
and implementation dependent values.  All arguments are
optional and have intent OUT.
The following arguments can be set by
.BR "option_stopwatch" "."
See
.BR "option_stopwatch" "(3)"
for further details on their meaning.
.I default_clock
is the set of clocks that are used when the
.I clock
argument is omitted in a call to a M_StopWatch routine.
.I io_unit_print
returns the unit for output from subroutine
.BI "print_watch." " io_unit_error"
returns the unit for any error messages printed by
M_StopWatch.  If
.I print_errors
is TRUE, then an error message will be printed to
.I io_unit_error
whenever an error condition occurs.  If
.I abort_errors
is TRUE, then the program will terminate when an error
condition occurs.
.I print_form
is the format used by
.BR "print_watch" "(3)"
when the
.I form
argument is omitted.

The remaining arguments return system information that
can not be changed.

Since an interface to the CPU clock is not part of the
Fortran 90 standard, the availability of clocks and
clock precisions are implementation dependent.  Not all
clocks are available in all implementations.  The
logical arguments
.I cpu_avail, user_avail, sys_avail
and
.I wall_avail
return TRUE if the respective clock is available in
this implementation.

The precision (the shortest time interval that can be
measured) of the clocks also varies between
implementations.  The real variables
.I cpu_prec
and
.I wall_prec
return the precision of the CPU and wall clocks, in
seconds.  It is assumed that the user and sys clocks
have the same precision as the CPU clock.  If the CPU
clock is not available, then
.I cpu_prec
will return 0., and similar for the wall clock.

The character string
.I version
returns the version number of M_StopWatch.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the requested value(s) might not
be returned.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 512
Failed to allocate required memory.  This error occurs
if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.LP

.SH EXAMPLES
logical user_is_there
.br
real cpu_prec

call inquiry_stopwatch(user_avail=user_is_there)
.br
call inquiry_stopwatch(cpu_prec=cpu_prec)

The first call determines if the user clock is
available in this implementation.  The second call
determines the shortest time that can be measured by
the CPU clock.

.SH BUGS
None known.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), join_watchgroup(3),
leave_watchgroup(3), option_stopwatch(3),
pause_watch(3), print_watch(3), read_watch(3),
reset_watch(3), start_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!                 INQUIRY_STOPWATCH
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine inquiry_stopwatch(default_clock,io_unit_print,io_unit_error, &
                   print_errors,abort_errors,print_form,cpu_avail,user_avail, &
                   sys_avail,wall_avail,cpu_prec,wall_prec,version,err)
!          -----------------
character(len=*),parameter :: ident_inquiry_stopwatch='M_stopwatch::inquiry_stopwatch(3f): returns M_StopWatch options and system'

!----------------------------------------------------
! This routine allows the user to determine the value of options set by
! option_stopwatch and certain implementation/system dependent values.
!----------------------------------------------------
!----------------------------------------------------
! Dummy arguments

character(len=*), optional, intent(out), dimension(:) :: default_clock
integer, optional, intent(out) :: io_unit_print, io_unit_error
logical, optional, intent(out) :: print_errors, abort_errors
character(len=*), optional, intent(out) :: print_form
logical, optional, intent(out) :: cpu_avail, user_avail, sys_avail, wall_avail
real, optional, intent(out) :: cpu_prec, wall_prec
character(len=*), optional, intent(out) :: version
integer, optional, intent(out) :: err

!----------------------------------------------------
!----------------------------------------------------
! Local variables:

integer :: r
real :: cpu,cpu2,user,sys

!----------------------------------------------------
!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=0
end if

! default_clocks

if (present(default_clock)) then
   if (.not. allocated(default_clocks)) then
      call option_stopwatch(default_clock=(/"cpu ","user","sys ","wall"/),err=err)
   end if

   default_clock = "    "
   default_clock(1:ubound(default_clocks,dim=1)) = default_clocks
end if

! i/o unit numbers

if (present(io_unit_error)) then
   io_unit_error = errunit
end if
if (present(io_unit_print)) then
   io_unit_print = iounit
end if

! behavior on errors

if (present(print_errors)) then
   print_errors = errprint
end if
if (present(abort_errors)) then
   abort_errors = errabort
end if

! format for printing time

if (present(print_form)) then
   print_form = default_form
end if

! available clocks

call system_cpu_time(cpu,user,sys)

if (present(cpu_avail)) then
   if (cpu < 0.0) then
      cpu_avail = .false.
   else
      cpu_avail = .true.
   end if
end if

if (present(user_avail)) then
   if (user < 0.0) then
      user_avail = .false.
   else
      user_avail = .true.
   end if
end if

if (present(sys_avail)) then
   if (sys < 0.0) then
      sys_avail = .false.
   else
      sys_avail = .true.
   end if
end if

if (present(wall_avail)) then
   call system_clock(count_rate=r)
   if (r == 0) then
      wall_avail = .false.
   else
      wall_avail = .true.
   end if
end if

! cpu precision, by calling system_cpu_time until the cpu clock changes

if (present(cpu_prec)) then
   if (cpu >= 0.0) then
      call system_cpu_time(cpu,user,sys)
      call system_cpu_time(cpu2,user,sys)
      do
         if (cpu2 /= cpu) then
            exit
         end if
         call system_cpu_time(cpu2,user,sys)
      end do
      cpu_prec = cpu2 - cpu
   else
      cpu_prec = 0.0
   end if
end if

! wall clock precision

if (present(wall_prec)) then
   call system_clock(count_rate=r)
   if (r == 0) then
      wall_prec = 0.0
   else
      wall_prec = 1.0/r
   end if
end if

! M_StopWatch version number

if (present(version)) then
   version = sw_version
end if

end subroutine inquiry_stopwatch
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file create_watchgroup.3m_stopwatch.txt
.TH CREATE_WATCHGROUP 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
create_watchgroup(3f) - [M_stopwatch] creates a M_StopWatch watch group (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "create_watchgroup" "(watch, handle, err)"

.IP
type (watchtype), intent(IN) ::  watch
.IP OR
type (watchtype), intent(IN) ::  watch(:)

.IP
type (watchgroup), intent(OUT) ::  handle
.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Creates a new watch group and returns a handle for it.
A watch group must be created by this routine before it
is passed to any other M_StopWatch routines.  In Fortran
90 it is impossible to test whether or not a watch
group has been created, and using a watch group that
has not been created may cause the program to crash.
It is not an error to create a watch group that has
already been created, however the prior information and
memory locations will be lost.  Watch groups should be
destroyed (see
.BR "destroy_watchgroup" "(3))"
before they are recreated.  Also, local variable watch
groups should be destroyed before returning from a
subroutine, to avoid memory leaks.

One or more watches may be optionally specified.  If
.I watch
is present, the watch group will initially contain the
specified watch(es).  If
.I watch
is omitted, the watch group will initially be empty.
Watches can be added and removed from the group with
.B join_watchgroup
and
.B leave_watchgroup.
The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to start the group with one watch, or an array of type
.I watchtype
to start the group with several watches.

The argument
.I handle
is a variable of type
.I watchgroup
that will subsequently be used to access the watch
group.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch group will not be
created.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1
Watch needs to be created.  This error occurs if you
attempt to put a watch that has been destroyed in the
group.  The watch must first be created again.  See
also the comment about watches that have never been
created in the BUGS section.

.IP 512
Failed to allocate required memory.  When a group is
created, memory is allocated for the group.  Also, when
.B create_watchgroup
is called with an array of watches, temporary memory is
allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array of watches.  The
group is created, but be aware that other problems
could develop as a result of the deallocate error.

.LP

.SH EXAMPLES
type (watchtype) w(3)
.br
type (watchgroup) g1, g2
.br
integer errcode

call create_watchgroup(handle=g1)
.br
call create_watchgroup(w, g2, err=errcode)

The first call creates an empty group
.I g1.
The second call creates the group
.I g2
with three watches, and returns a status code.

.SH BUGS
It cannot be determined whether or not a watch variable
has been created (passed as an argument to
.B create_watch).
If a watch that has never been created is passed into
.B create_watchgroup,
it might generate a Fortran error due to passing a
pointer with undefined association status to the
Fortran intrinsic function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watch(3), destroy_watchgroup(3),
destroy_watch(3), end_pause_watch(3),
inquiry_stopwatch(3), join_watchgroup(3),
leave_watchgroup(3), option_stopwatch(3),
pause_watch(3), print_watch(3), read_watch(3),
reset_watch(3), start_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine create_watchgroup_actual(watch,handle,err)

character(len=*),parameter :: ident_create_watchgroup='M_stopwatch::create_watchgroup(3f): creates a M_StopWatch watch group'

! handle should not be an optional argument.  It must be present.  It was made
! optional to deal with F's requirement that nonoptional arguments do not
! follow optional arguments, and to keep upward compatibility with 1) a watch
! need not be provided and 2) argument order.  This should not cause confusion
! on the user's part because 1) the documentation will not indicate handle is
! optional, and 2) calling this routine without handle is meaningless
type (watch_pointer), optional, intent(in), dimension(:) :: watch
type (watchgroup), optional, intent(out) :: handle
integer, optional, intent(out) :: err

type (watch_list), pointer :: list_entry
integer :: i,erralloc
integer :: itemp ! change for 0.8.1; see explanation below

! Creates a new watch group and returns a handle for it.  If watch is
! present then the group will initially contain the given watches; otherwise
! the group will initially be empty.

if (present(err)) then
   err=0
end if

if (.not. present(handle)) then ! just in case it gets called without handle
   return
end if

! desired:  if the group already exists (associated(head)==.true.)
! then either destroy_watchgroup or set an error and don"t create.
! Unfortunately, I cannot test associated(head) because head will (correctly)
! have an undefined association status the first time a watch is passed to
! create_watchgroup

if (present(watch)) then
   handle%wgsize = ubound(watch,dim=1)
   allocate(handle%head,stat=erralloc)
   if (erralloc > 0) then
      call err_handler_watch(ERR_ALLOC,"create_watchgroup","", "Group not created.",err)
      return
   end if
   list_entry => handle%head
   do i=1,ubound(watch,dim=1)-1
      if (.not. associated(watch(i)%ptr)) then
         call err_handler_watch(ERR_CREATE,"create_watchgroup","", "Group not created.",err)
         handle%wgsize = 0
         nullify(handle%head)
         return
      else
         list_entry%this_watch => watch(i)%ptr
         allocate(list_entry%next,stat=erralloc)
         if (erralloc > 0) then
            call err_handler_watch(ERR_ALLOC,"create_watchgroup","", "Group not created.",err)
            handle%wgsize = 0
            nullify(handle%head)
            return
         else
            list_entry => list_entry%next
         end if
      end if
   end do
! this is the only change for version 0.8.1
! put ubound in temporary because of PSR VAST bug
   itemp = ubound(watch,dim=1)
   list_entry%this_watch => watch(itemp)%ptr
!   list_entry%this_watch => watch(ubound(watch,dim=1))%ptr
   nullify(list_entry%next)
else
   handle%wgsize = 0
   nullify(handle%head)
end if

end subroutine create_watchgroup_actual
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!----------------------------------------------------
! Alternate forms for create_watchgroup
!----------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine create_watchgroup_a(watch,handle,err)
!          -------------------
type (watchtype), intent(in), dimension(:) :: watch
type (watchgroup), intent(out) :: handle
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
integer :: erralloc,i
allocate(watches(size(watch)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"create_watchgroup","", "Group not created.",err)
else
   do i=1,size(watch)
      watches(i)%ptr => watch(i)%ptr
   end do
   call create_watchgroup_actual(watches,handle,err)
end if
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"create_watchgroup","", "Group created, but further problems may develop.",err)
end if

end subroutine create_watchgroup_a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine create_watchgroup_s(watch,handle,err)
!          -------------------
! handle should not be optional.  see create_watchgroup_actual
type (watchtype), optional, intent(in) :: watch
type (watchgroup), optional, intent(out) :: handle
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
if (present(watch)) then
   watches(1)%ptr => watch%ptr
   call create_watchgroup_actual(watches,handle,err)
else
   call create_watchgroup_actual(handle=handle,err=err)
end if
end subroutine create_watchgroup_s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file destroy_watchgroup.3m_stopwatch.txt
.TH DESTROY_WATCHGROUP 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
destroy_watchgroup(3f) - [M_stopwatch] destroys a M_StopWatch watch group (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "destroy_watchgroup" "(handle, err)"

.IP
type (watchgroup), intent(INOUT) ::  handle
.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Destroys a watch group.  Only the group is destroyed,
not the watches in the group.  To avoid memory leaks,
watch groups should be destroyed when no longer useful,
before being recreated, and before returning from a
subroutine in which the watch group is a local
variable.

The argument
.I handle
is a variable of type
.I watchgroup
that is the handle for the group to be destroyed.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch group will not be
created.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
memory used for the group.  The group is destroyed, but
be aware that other problems could develop as a result
of the deallocate error.

.LP

.SH EXAMPLES
type (watchgroup) g1, g2
.br
integer errcode

call destroy_watchgroup(g1)
.br
call destroy_watchgroup(g2, errcode)

The first call destroys the group
.I g1.
The second call destroys the group
.I g2
and returns a status code.

.SH BUGS
None known.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watch(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
join_watchgroup(3), leave_watchgroup(3),
option_stopwatch(3), pause_watch(3), print_watch(3),
read_watch(3), reset_watch(3), start_watch(3),
stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
subroutine destroy_watchgroup(handle,err)

character(len=*),parameter :: ident_destroy_watchgroup='M_stopwatch::destroy_watchgroup(3f): destroys a M_StopWatch watch group'

type (watchgroup), intent(in out) :: handle
integer, optional, intent(out) :: err

integer :: erralloc

if (present(err)) then
   err=0
end if

if (associated(handle%head)) then
   if (handle%wgsize > 1) then
      call free_watch_list(handle%head,err)
   end if
   if (handle%wgsize > 0) then
      deallocate(handle%head,stat=erralloc)
      if (erralloc > 0) then
         call err_handler_watch(ERR_DEALLOC,"destroy_watchgroup","", "Group destroyed, but there may be a memory leak.",err)
      end if
      nullify(handle%head)
   end if
   handle%wgsize = 0
end if

end subroutine destroy_watchgroup
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
recursive subroutine free_watch_list(list_entry,err)
!                    ---------------
type (watch_list), intent(in out) :: list_entry
integer, optional, intent(out) :: err

integer :: erralloc

if (present(err)) then
   err=0
end if

if (associated(list_entry%next%next)) then
   call free_watch_list(list_entry%next,err)
end if
deallocate(list_entry%next,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"destroy_watchgroup","", "Group being destroyed, but there may be a memory leak.",err)
end if
nullify(list_entry%next)

end subroutine free_watch_list
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file join_watchgroup.3m_stopwatch.txt
.TH JOIN_WATCHGROUP 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
join_watchgroup(3f) - [M_stopwatch] adds a M_StopWatch watch to a watch
group (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "join_watchgroup" "(watch, handle, err)"

.IP
type (watchtype), intent(IN) ::  watch
.IP OR
type (watchtype), intent(IN) ::  watch(:)

.IP
type (watchgroup), intent(INOUT) ::  handle
.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Adds the specified watch(es) to the specified watch
group.  The watch(es) and group must have been
previously created with
.B create_watch
and
.B create_watchgroup.

One or more watches must be specified.  The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to add one watch, an array of type
.I watchtype
to add several watches.

The watch group is specified by
.I handle,
a variable of type
.I watchgroup.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch(es) will not be added
to the group.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 1
Watch needs to be created.  This error occurs if you
attempt to add a watch that has been destroyed to a
group.  The watch must first be created again.  See
also the comment about watches that have never been
created in the BUGS section.

.IP 512
Failed to allocate required memory.  Memory is
allocated in the group when a watch is added.  Also,
when
.B join_watchgroup
is called with an array or group of watches, temporary
memory is allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array or group of watches.
The watches are added to the group, but be aware that
other problems could develop as a result of the
deallocate error.

.LP

.SH EXAMPLES
type (watchtype) w1, w2(3)
.br
type (watchgroup) g1
.br
integer errcode

call join_watchgroup(w1, g1)
.br
call join_watchgroup(w2, g1, errcode)

The first call adds the watch
.I w1
to watch group
.I g1.
The second call adds three watch to
.I g1
and returns a status code.

.SH BUGS
It cannot be determined whether or not a watch variable
or watch group has been created (passed as an argument
to
.B create_watch
or
.BR "create_watchgroup" ")."
If a watch or watch group that has never been created
is passed into
.B join_watchgroup,
it might generate a Fortran error due to passing a
pointer with undefined association status to the
Fortran intrinsic function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
leave_watchgroup(3), option_stopwatch(3),
pause_watch(3), print_watch(3), read_watch(3),
reset_watch(3), start_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!-----------------------------------------------------------------------------------------------------------------------------------
!                 JOIN_GROUP
!-----------------------------------------------------------------------------------------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine join_watchgroup_actual(watch,handle,err)
!          ----------------------
character(len=*),parameter :: ident_join_watchgroup='M_stopwatch::join_watchgroup(3f): adds a M_StopWatch watch to a watch'
type (watch_pointer), intent(in), dimension(:) :: watch
type (watchgroup), intent(in out) :: handle
integer, optional, intent(out) :: err

type (watch_list), pointer :: list_entry
integer :: i,lolim,erralloc

! Adds watches to a watch group

if (present(err)) then
   err=0
end if

if (.not. associated(handle%head)) then  ! create the first entry for an empty group
   if (.not. associated(watch(1)%ptr)) then
      call err_handler_watch(ERR_CREATE,"join_watchgroup","", "No watches added to group.",err)
      return
   else
      allocate(handle%head,stat=erralloc)
      if (erralloc > 0) then
         call err_handler_watch(ERR_ALLOC,"join_watchgroup","", "Watch(es) not added to group.",err)
         return
      end if
      handle%wgsize = 1
      handle%head%this_watch => watch(1)%ptr
      nullify(handle%head%next)
      lolim = 2
   end if
else
   lolim = 1
end if

do i=lolim,ubound(watch,dim=1) ! add watches to the front of the linked list
   if (.not. associated(watch(i)%ptr)) then
      call err_handler_watch(ERR_CREATE,"join_watchgroup","", "Watch not added to group.",err)
   else
      list_entry => handle%head
      nullify(handle%head)
      allocate(handle%head,stat=erralloc)
      if (erralloc > 0) then
         call err_handler_watch(ERR_ALLOC,"join_watchgroup","", "Watch not added to group.",err)
         return
      end if
      handle%wgsize = handle%wgsize + 1
      handle%head%this_watch => watch(i)%ptr
      handle%head%next => list_entry
   end if
end do

end subroutine join_watchgroup_actual
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!----------------------------------------------------
! Alternate forms for join_watchgroup
!----------------------------------------------------
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine join_watchgroup_a(watch,handle,err)
!          -----------------
type (watchtype), intent(in), dimension(:) :: watch
type (watchgroup), intent(in out) :: handle
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
integer :: erralloc,i
allocate(watches(size(watch)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"join_watchgroup","", "Watches not added to group.",err)
else
   do i=1,size(watch)
      watches(i)%ptr => watch(i)%ptr
   end do
   call join_watchgroup_actual(watches,handle,err)
end if
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"join_watchgroup","", "Watches added to group, but further problems may develop.",err)
end if
end subroutine join_watchgroup_a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine join_watchgroup_s(watch,handle,err)
!          -----------------
type (watchtype), intent(in) :: watch
type (watchgroup), intent(in out) :: handle
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
call join_watchgroup_actual(watches,handle,err)

end subroutine join_watchgroup_s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$BLOCK NULL -file leave_watchgroup.3m_stopwatch.txt
.TH LEAVE_WATCHGROUP 3 "September 22, 2017" "M_StopWatch 1.1" "M_STOPWATCH PROCEDURES"
.PD 0.0v
." -----------------------------------------------------------------
." * set default formatting
." disable hyphenation
.nh
." disable justification (adjust text to left margin only)
.ad l
." -----------------------------------------------------------------

.SH NAME
leave_watchgroup(3f) - [M_stopwatch] removes a M_StopWatch watch from a
watch group (LICENSE:PD)

.SH SYNOPSIS
subroutine
.BI "leave_watchgroup" "(watch, handle, err)"

.IP
type (watchtype), intent(IN) ::  watch
.IP OR
type (watchtype), intent(IN) ::  watch(:)

.IP
type (watchgroup), intent(INOUT) ::  handle
.IP
integer, optional, intent(OUT) ::  err

.SH DESCRIPTION
Removes the specified watch(es) from the specified
watch group.

One or more watches must be specified.  The argument
.I watch
can be a single variable of type
.I watchtype
(see
.BR "M_stopwatch" "(3))"
to remove one watch, or an array of type
.I watchtype
to remove several watches.

The watch group is specified by
.I handle,
a variable of type
.I watchgroup.

.SH DIAGNOSTICS
If present, the optional intent OUT integer argument
.I err
returns a status code.  The code is the sum of the
values listed below.

An error message will be printed to a specified I/O
unit (unit 6 by default) if
.I print_errors
is TRUE (default is TRUE). The error message contains
more detail about the cause of the error than can be
obtained from just the status code, so you should set
.I print_errors
to TRUE if you have trouble determining the cause of
the error.

If
.I abort_errors
is TRUE (default is FALSE), the program will terminate
on an error condition.  Otherwise, the program will
continue execution but the watch(es) will not be
removed from the group.

See
.BR "option_stopwatch" "(3)"
for further information on
.I print_errors, abort_errors
and I/O units.

The relevant status codes and messages are:

.IP 0
No errors; execution successful.

.IP 128
Watch not found in given group.  This occurs when you
attempt to remove a watch from a group that it does not
belong to.  One cause of this is if you destroy a watch
and later try to remove it from a group.

.IP 512
Failed to allocate required memory.  When
.B leave_watchgroup
is called with an array or group of watches, temporary
memory is allocated.  This error occurs if the Fortran
.B allocate
statement returns a nonzero status indicating that
memory could not be allocated.  Avoid memory leaks by
always destroying watches and groups before recreating
them, and destroying local variable watches and groups
before returning from a subroutine.

.IP 1024
Error occurred while deallocating memory.  This error
occurs if the Fortran
.B deallocate
statement returns a nonzero status while deallocating
temporary memory used for an array or group of watches
or the memory used for an entry in the group.  The
watches are removed from the group, but be aware that
other problems could develop as a result of the
deallocate error.

.LP

.SH EXAMPLES
type (watchtype) w1, w2(3)
.br
type (watchgroup) g1
.br
integer errcode

call leave_watchgroup(w1, g1)
.br
call leave_watchgroup(w2, g1, errcode)

The first call removes the watch
.I w1
from watch group
.I g1.
The second call removes three watch from
.I g1
and returns a status code.

.SH BUGS
It cannot be determined whether or not a watch variable
or watch group has been created (passed as an argument
to
.B create_watch
or
.BR "create_watchgroup" ")."
If a watch or watch group that has never been created
is passed into
.B leave_watchgroup,
it might generate a Fortran error due to passing a
pointer with undefined association status to the
Fortran intrinsic function
.B associated.
However, some compilers will allow this as an extension
to the Fortran 90 standard and recognize that the
pointer is not associated, in which case the ``Watch
needs to be created'' error message is generated.

.SH AUTHOR
William F. Mitchell, william.mitchell@nist.gov
.br
National Institute of Standards and Technology

.SH SEE ALSO
M_stopwatch(3), create_watchgroup(3), create_watch(3),
destroy_watchgroup(3), destroy_watch(3),
end_pause_watch(3), inquiry_stopwatch(3),
join_watchgroup(3), option_stopwatch(3), pause_watch(3),
print_watch(3), read_watch(3), reset_watch(3),
start_watch(3), stop_watch(3)
$BLOCK END
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!                 LEAVE_GROUP
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine leave_watchgroup_actual(watch,handle,err)

character(len=*),parameter :: ident_leave_watchgroup='M_stopwatch::leave_watchgroup(3f): removes a watch from a watchgroup'

type (watch_pointer), intent(in), dimension(:) :: watch
type (watchgroup), intent(in out) :: handle
integer, optional, intent(out) :: err

type (watch_list), pointer :: list_entry, parent
integer :: i, erralloc

! Removes watches from a watch group

if (present(err)) then
   err=0
end if

! loop through the watches

do i=1,ubound(watch,dim=1)

! find the watch

   nullify(parent)
   list_entry => handle%head
   do
      if (.not. associated(list_entry)) then
         exit
      end if
      if (associated(list_entry%this_watch,watch(i)%ptr)) then
         exit
      end if
      parent => list_entry
      list_entry => list_entry%next
   end do
   if (.not. associated(list_entry)) then
      call err_handler_watch(ERR_GROUP,"leave_watchgroup",watch(i)%ptr%name, "Watch not removed from group.",err)
   else
      if (.not. associated(parent)) then ! remove head of list
         handle%head => list_entry%next
         deallocate(list_entry,stat=erralloc)
      else ! remove one from the interior of the list or tail
         parent%next => list_entry%next
         deallocate(list_entry,stat=erralloc)
      end if
      if (erralloc > 0) then
         call err_handler_watch(ERR_DEALLOC,"leave_watchgroup","", "Watch removed from group, but there may be a memory leak.",err)
      end if
      handle%wgsize = handle%wgsize - 1
   end if

end do

end subroutine leave_watchgroup_actual
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
! Alternate forms for leave_watchgroup
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine leave_watchgroup_a(watch,handle,err)
!          ------------------
type (watchtype), intent(in), dimension(:) :: watch
type (watchgroup), intent(in out) :: handle
integer, optional, intent(out) :: err
type (watch_pointer), allocatable, dimension(:) :: watches
integer :: erralloc,i
allocate(watches(size(watch)),stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_ALLOC,"leave_watchgroup","", "Watches not removed from group.",err)
else
   do i=1,size(watch)
      watches(i)%ptr => watch(i)%ptr
   end do
   call leave_watchgroup_actual(watches,handle,err)
end if
deallocate(watches,stat=erralloc)
if (erralloc > 0) then
   call err_handler_watch(ERR_DEALLOC,"leave_watchgroup","", "Watches removed from group, but further problems may develop.",err)
end if
end subroutine leave_watchgroup_a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine leave_watchgroup_s(watch,handle,err)
!          ------------------
type (watchtype), intent(in) :: watch
type (watchgroup), intent(in out) :: handle
integer, optional, intent(out) :: err
type (watch_pointer), dimension(1) :: watches
watches(1)%ptr => watch%ptr
call leave_watchgroup_actual(watches,handle,err)
end subroutine leave_watchgroup_s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!       ROUTINES THAT ARE NOT DIRECTLY CALLABLE BY THE USER
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine which_clocks_a(clock,from,err)
!----------------------------------------------------
! This routine sets the flags do_cpu, do_user, do_sys and do_wall to indicate
! which clocks should be operated on.  clock is an array of clock names
! ("cpu", "user", "sys", and "wall") for which to set the flag true
!----------------------------------------------------
!----------------------------------------------------
! Dummy arguments
character(len=*), intent(in), dimension(:) :: clock
character(len=*), intent(in) :: from
integer, intent(in out), optional :: err
!----------------------------------------------------
!----------------------------------------------------
! Local variables:
integer :: i, r
real :: cpu, user, sys
!----------------------------------------------------
!----------------------------------------------------
! Begin executable code

call system_cpu_time(cpu,user,sys)
call system_clock(count_rate=r)
do_cpu = .false.
do_user = .false.
do_sys = .false.
do_wall = .false.
do i=1,size(clock)
   select case (clock(i))
      case("cpu")
         if (cpu >= 0.0) then
            do_cpu = .true.
         else
            call err_handler_watch(ERR_CLOCK,from,"cpu", "Requested action not performed on cpu clock.",err)
         end if
      case("user")
         if (user >= 0.0) then
            do_user = .true.
         else
            call err_handler_watch(ERR_CLOCK,from,"user", "Requested action not performed on user clock.",err)
         end if
      case("sys")
         if (sys >= 0.0) then
            do_sys = .true.
         else
            call err_handler_watch(ERR_CLOCK,from,"sys", "Requested action not performed on sys clock.",err)
         end if
      case("wall")
         if (r /= 0) then
            do_wall = .true.
         else
            call err_handler_watch(ERR_CLOCK,from,"wall", "Requested action not performed on wall clock.",err)
         end if
      case default
         call err_handler_watch(ERR_CLOCK,from,clock(i), "Requested action not performed on this clock.",err)
   end select
end do

end subroutine which_clocks_a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
! Alternate forms for which_clocks
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine which_clocks_s(clock,from,err)
character(len=*), intent(in) :: clock
character(len=*), intent(in) :: from
integer, intent(in out), optional :: err
   call which_clocks_a( (/ clock /) ,from,err)
end subroutine which_clocks_s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
$!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!          -----------------
subroutine err_handler_watch(code,routine,string1,string2,err)
!          -----------------

!----------------------------------------------------
! This routine handles errors by a user specified (through option_stopwatch)
! combination of printing messages, setting the error code, and aborting.
!----------------------------------------------------

!----------------------------------------------------
! Dummy arguments

integer, intent(in) :: code
character(len=*), intent(in) :: routine,string1, string2
integer, intent(in out), optional :: err

integer :: errio
!----------------------------------------------------
! Begin executable code

if (present(err)) then
   err=ior(err,code)
end if

if (errprint) then
  write(unit=errunit,fmt=*,iostat=errio) " "
  if (errio > 0) then  ! failed to write to error file; try printed output file
     write(unit=iounit,fmt=*,iostat=errio) " "
     if (errio == 0) then
       write(unit=iounit,fmt=*) "     ***** WARNING from M_StopWatch error handler *****"
       write(unit=iounit,fmt=*) "     Unable to write to error I/O unit ",errunit
       write(unit=iounit,fmt=*) "     Switching error output to printed output unit ",iounit
       write(unit=iounit,fmt=*) "     ************************************************"
       write(unit=iounit,fmt=*)
     end if
     errunit = iounit
  end if

  if (errio == 0) then ! if failed on iounit, too, then give up

     write(unit=errunit,fmt=*) "     ***** WARNING from M_StopWatch routine ",routine," *****"
     select case (code)
      case(ERR_CLOCK)
          write(unit=errunit,fmt=*) "     Invalid clock type ",trim(string1),"."
      case(ERR_BAD_STATE)
          write(unit=errunit,fmt=*) "     Watch named ",trim(string1)," is in the wrong state for this operation."
      case(ERR_UNK_STATE)
          write(unit=errunit,fmt=*) "     Watch named ",trim(string1)," is in an unknown state."
      case(ERR_IO)
          write(unit=errunit,fmt=*) "     I/O unit number ",trim(string1)," is not open for writing."
      case(ERR_TMC)
          write(unit=errunit,fmt=*) "     Too many clocks specified at clock type ",trim(string1)
      case(ERR_C2LONG)
          write(unit=errunit,fmt=*) "     Character string '",trim(string1),"' too long."
      case(ERR_ALLOC)
          write(unit=errunit,fmt=*) "     Failed to allocate required memory."
      case(ERR_NAMES)
          write(unit=errunit,fmt=*) "     Number of names is not equal to number of watches."
      case(ERR_GROUP)
          write(unit=errunit,fmt=*) "     Watch named ",trim(string1)," not found in given group."
      case(ERR_DEALLOC)
          write(unit=errunit,fmt=*) "     Error occurred while deallocating memory."
      case(ERR_CREATE)
          write(unit=errunit,fmt=*) "     Watch needs to be created."
      case(ERR_FORM)
          write(unit=errunit,fmt=*) "     Illegal output form "",trim(string1),""."
      case default
          write(unit=errunit,fmt=*) "     Error handler called with invalid error code."
     end select
     write(unit=errunit,fmt=*) "     ",string2
     write(unit=errunit,fmt=*) "     ******************************************************"
     write(unit=errunit,fmt=*)
  end if
end if

if (errabort) then
   if (errprint) then
      write(unit=errunit,fmt=*) "Program aborting: user request to abort on errors in M_StopWatch."
   end if
   stop
end if

end subroutine err_handler_watch
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
$IFDEF GITHUB
subroutine system_cpu_time(total,user,system)


real,intent(out)   :: user,system,total
real(kind=c_float) :: c_user,c_system,c_total

interface
   subroutine c_cpu_time(c_total,c_user,c_system) bind (C,NAME='my_stopwatch_cpu_time')
      import c_float
      real(kind=c_float) :: c_total,c_user,c_system
   end subroutine c_cpu_time
end interface

call c_cpu_time(c_total,c_user,c_system)
user=c_user
system=c_system
total=c_total
end subroutine system_cpu_time
$ENDIF
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_stopwatch
$!==================================================================================================================================
$!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
$!==================================================================================================================================
